---
output:
  pdf_document:
    latex_engine: xelatex
geometry: margin=0.2in
---
# Load Packages

```{r setup, include=FALSE, message = FALSE, warning = FALSE}
knitr::opts_knit$set(root.dir = "/home/glennrdx/Documents/lab_projects/microenvironments/01_data/")

# Load libraries
library(tidyverse, quietly = T) # CRAN
library(Matrix, quietly = T) # CRAN
library(ggplot2, quietly = T) # CRAN
library(data.table, quietly = T) # CRAN
library(Seurat, quietly = T) # CRAN
library(dplyr, quietly = T) # CRAN
library(viridis, quietly = T) # CRAN
library(sctransform, quietly = T) # CRAN
library(RANN, quietly = T) # CRAN
library(ggrastr, quietly = T) # CRAN
library(paletteer)
library(scry, quietly = T) # bioconductor
library(SingleCellExperiment, quietly = T) # bioconductor
```

# Load Data

```{r}
iss_expr <- readRDS("janesick_2023/raw_clean/iss_expr_clean.RDS")
iss_meta <- readRDS("janesick_2023/raw_clean/iss_meta_clean.RDS")
```

# Part 2: Classifying invasive tumours as surface / core

### Goal:  
Determine the percentage of tumourous neighbours of 20 closest cells for each invasive tumour. 'cells' object contains a row for each cell and annotation columns for various features.
 - A new feature will be created called 'perc_tumours' representing this number.

### Method:  
#### Step 1:
For each invasive tumour in 'cells':
  - Calculate square region around the centroid  
  - For all cells in that region, calculate distance to initial invasive tumour cell  
  - Filter to top 30 closest neighbouring cells  
  - Calculate percentage of neighbours that are tumourous and save number in 'cells' dataframe  
  
#### Step 2:
Plot spatial data, where:
  - non invasive tumours are grey  
  - invasive tumours with less than 95% of tumourous neighbours are dark pink (surface)  
  - invasive tumours with more than 95% of tumourous neighbours are light pink (core)  
  
```{r}
# Get invasive cells
invasive_cells <- iss_meta[iss_meta$Annotation == "Invasive_Tumor", ]
iss_meta$perc_tumours <- NA_real_ # NA_real_ is an NA value in place of a floating point number

start_time <- Sys.time()

# Extract coordinates matrix for nearest-neighbor search
coords_all <- as.matrix(iss_meta[, c("x_centroid", "y_centroid")])
coords_invasive <- as.matrix(invasive_cells[, c("x_centroid", "y_centroid")])

# Find 31 nearest neighbors for each invasive cell (includes the cell itself)
# nn2 is extremely fast (uses KD-trees in C++)
nn <- RANN::nn2(data = coords_all, query = coords_invasive, k = 21)

# Indices of nearest neighbors (each row = one invasive cell)
neighbor_indices <- nn$nn.idx[, -1, drop = FALSE]  # remove self, keep matrix

# Create a logical vector: which cells are tumourous?
tumourous_flags <- iss_meta$Annotation %in% c("Invasive_Tumor", "Prolif_Invasive_Tumor")

# Calculate percentage of tumourous neighbors for each invasive cell safely
perc_tumours <- apply(neighbor_indices, 1, function(idx) {
  mean(tumourous_flags[idx])
})

# Assign values back to main data frame
iss_meta$perc_tumours[match(invasive_cells$cell_id, iss_meta$cell_id)] <- perc_tumours

save(iss_meta, file = 'cells_RANN.RData')

end_time <- Sys.time()

cat("Classification took:", round(end_time - start_time, 2), "seconds.")
```

```{r}
# Set surface / core labels based on the percentage of neighbours that are tumours (perc_tumours)
threshold <- 0.90
iss_meta$surface_class_nn <- ifelse(
  is.na(iss_meta$perc_tumours), NA_character_,
  ifelse(iss_meta$perc_tumours < threshold, "Surface", "Core")
)
```

```{r}
table(iss_meta$surface_class_nn)
```


```{r}
# Make Seurat object with ISS data
iss_obj <- CreateSeuratObject(counts = iss_expr, meta.data = iss_meta)

# filter to invasive cells only
iss_obj_invasive <- subset(iss_obj, subset = Annotation %in% 'Invasive_Tumor')
saveRDS(iss_obj_invasive, file = "janesick_2023/processed/iss_obj_invasive.RDS")
```

\newpage

# Plot
```{r, fig.width=7.87, fig.height = 6.5, dpi=300, dev='tiff', out.width='100%'}
ggplot(iss_meta, aes(x = x_centroid, y = y_centroid)) +
  geom_point(aes(color = surface_class_nn), size = 0.01, alpha = 0.8, shape = '.') +
  scale_color_manual(values = c("Surface" = "#C90065", "Core" = "#fac0da", "Other" = "grey75"), na.value = "grey75") +
  scale_x_reverse() +
  coord_fixed() +
  guides(color = guide_legend(override.aes = list(shape = 16, size = 3))) +
  theme_minimal() +
  theme(
    legend.position = "bottom", 
    legend.box = "horizontal", 
    legend.margin = margin(0, 0, 0, 0), 
    plot.margin = margin(0, 0, 0, 0, "pt")
    )
```

\newpage
# Calculate 'tumour_depth' value

```{r}
# Calculate tumour_depth: distance from core cells to nearest surface cell
# Surface cells get depth = 0

# Initialize tumour_depth column
iss_meta$tumour_depth <- NA_real_

# Set surface cells to depth 0
iss_meta$tumour_depth[iss_meta$surface_class_nn == "Surface"] <- 0

# Get core cells
core_cells <- iss_meta[iss_meta$surface_class_nn == "Core", ]

if (nrow(core_cells) > 0) {
  # Get surface cell coordinates
  surface_cells <- iss_meta[iss_meta$surface_class_nn == "Surface", ]
  
  if (nrow(surface_cells) > 0) {
    # Extract coordinate matrices
    coords_surface <- as.matrix(surface_cells[, c("x_centroid", "y_centroid")])
    coords_core <- as.matrix(core_cells[, c("x_centroid", "y_centroid")])
    
    # Find nearest surface cell for each core cell
    nn <- RANN::nn2(data = coords_surface, query = coords_core, k = 1)
    
    # nn$nn.dists contains the distances to nearest surface cell
    nearest_surface_dist <- nn$nn.dists[, 1]
    
    # Assign distances back to main dataframe
    iss_meta$tumour_depth[match(core_cells$cell_id, iss_meta$cell_id)] <- nearest_surface_dist
  }
}

# Check results
summary(iss_meta$tumour_depth[iss_meta$surface_class_nn == "Core"])
summary(iss_meta$tumour_depth[iss_meta$surface_class_nn == "Surface"])
```

# Plot of tumour depth

```{r, fig.width=16*1.2, fig.height=12*1.2, dpi=300, dev='tiff', out.width='100%'}
ggplot(iss_meta, aes(x = x_centroid, y = y_centroid)) +
  geom_point(aes(color = tumour_depth), size = 0.1) +
  scale_color_gradientn(
    colors = paletteer_c("grDevices::Blue-Red 3", 30),
    na.value = "grey75",
    guide = guide_colorbar(
      barwidth = 1,   # length of the color bar
      barheight = 10,   # thickness
      ticks = FALSE,   # remove ticks if desired
      label.position = "right" # put labels on right
    ) 
  ) +
  scale_x_reverse() +
  coord_fixed() +
  theme_minimal() +
  theme(
    legend.position = "right", 
    legend.box = "vertical", 
    legend.margin = margin(0, 0, 0, 0), 
    plot.margin = margin(0, 0, 0, 0, "pt")
    )
```


# Cluster cells & draw plot coloured by clusters

```{r, fig.width=7.87, dpi=300, dev='tiff', out.width='100%'}
iss_obj_invasive <- NormalizeData(iss_obj_invasive)

iss_obj_invasive <- FindVariableFeatures(iss_obj_invasive)

iss_obj_invasive <- ScaleData(iss_obj_invasive)

iss_obj_invasive <- RunPCA(iss_obj_invasive)

ElbowPlot(iss_obj_invasive, ndims = 50, reduction = 'pca')
```

```{r}
iss_obj_invasive_nn <- FindNeighbors(iss_obj_invasive, dims = 1:10)
```

```{r, fig.width=7.87, dpi=300, dev='tiff', out.width='100%'}
iss_obj_invasive_clustered <- FindClusters(iss_obj_invasive_nn, resolution = 0.3, algorithm = 4)

iss_obj_invasive_clustered <- RunUMAP(iss_obj_invasive_clustered, dims = 1:10)

DimPlot(iss_obj_invasive_clustered, group.by = "seurat_clusters", label = F) + scale_color_viridis_d(option = "turbo", na.value = "grey75") + ggtitle("Leiden Clustering of Invasive Tumour Cells")
```

```{r}
# Ensure 'cell_id' in 'cells' is character
iss_meta$cell_id <- as.character(iss_meta$cell_id)

# Extract Seurat cluster assignments for invasive tumor cells
clusters <- Idents(iss_obj_invasive_clustered)  # vector of cluster labels
cluster_df <- data.frame(
  cell_id = names(clusters),
  cluster = as.character(clusters),
  stringsAsFactors = FALSE
)

# Merge cluster info into 'cells'
iss_meta <- merge(iss_meta, cluster_df, by = "cell_id", all.x = TRUE)
saveRDS(iss_meta, "janesick_2023/processed/iss_meta.RDS")
```

```{r, fig.width=16, fig.height = 12, dpi=300, dev='tiff', out.width='100%'}
ggplot(iss_meta, aes(x = x_centroid, y = y_centroid)) +
  geom_point(aes(color = cluster), size = 0.1) +
  scale_color_viridis_d(option = "turbo", na.value = "grey75") +
  scale_x_reverse() +
  coord_fixed() +
  guides(color = guide_legend(override.aes = list(shape = 16, size = 3))) +
  theme_minimal() +
  theme(
    legend.position = "bottom", 
    legend.box = "horizontal", 
    legend.margin = margin(0, 0, 0, 0), 
    plot.margin = margin(0, 0, 0, 0, "pt")
    )
```

# Classify surface / core based on clusters
```{r}
# cluster's 4, 5 are NA
# cluster 3 is surface
# clusters 1, 2 are core
iss_meta <- iss_meta %>%
  mutate(surface_class_clusters = case_when(cluster %in% c(1,2) ~ "Core", 
                                            cluster %in% c(3) ~ "Surface", 
                                            cluster %in% c(4,5) ~ NA_character_,
                                            TRUE ~ NA_character_
  ))

table(iss_meta$surface_class_clusters)
```




## Save object
```{r}
# Make Seurat object with ISS data
iss_obj <- CreateSeuratObject(counts = iss_expr, meta.data = iss_meta)

# filter to invasive cells only
iss_obj_invasive <- subset(iss_obj, subset = Annotation %in% 'Invasive_Tumor')
saveRDS(iss_obj_invasive, file = "janesick_2023/processed/iss_obj_invasive.RDS")
```






