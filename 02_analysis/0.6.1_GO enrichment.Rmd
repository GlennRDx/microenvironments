---
output:
  pdf_document:
    latex_engine: xelatex
geometry: margin=0.2in
---

```{r setup, include=FALSE, message = FALSE, warning = FALSE}
# Load config.R
source("config.R") 

# Set root directory using the variable from config
knitr::opts_knit$set(root.dir = data_dir)

# Load libraries
library(tidyverse)
library(clusterProfiler) # Required for gseGO
library(org.Hs.eg.db)    # Required for mapping IDs
library(gage)
library(gageData)
```

```{r}
# --- DATA IMPORT ---

# 1. Define paths to the CSVs generated in 0.5.1
iss_path <- file.path(data_dir, "janesick_2023/processed/DGE_ISS_Surface_vs_Core.csv")
wtd_path <- file.path(data_dir, "janesick_2023/processed/DGE_WTD_Surface_vs_Core.csv")

# 2. Read the data (keeping original column names)
dge_iss <- read.csv(iss_path)
dge_wtd <- read.csv(wtd_path)
```


```{r}
# Function to perform GO enrichment analysis using gseGO
perform_go_enrichment <- function(df, ont, gene_col, fc_col) {
  
  # Ensure the specified columns exist
  if (!gene_col %in% colnames(df)) stop(paste("Column", gene_col, "not found in dataframe"))
  if (!fc_col %in% colnames(df)) stop(paste("Column", fc_col, "not found in dataframe"))

  # Convert gene symbols to Entrez IDs
  # Uses df[[gene_col]] to access the variable column name
  entrez_ids <- mapIds(org.Hs.eg.db, keys = df[[gene_col]], column = "ENTREZID", keytype = "ALIAS", multiVals = "first")
  entrez_ids <- na.omit(entrez_ids)
  
  # Remove duplicates
  df <- df[!duplicated(entrez_ids[df[[gene_col]]]), ]
  entrez_ids <- entrez_ids[!duplicated(entrez_ids)]
  
  # Create a named vector of logFC values
  # Uses df[[fc_col]] to access the variable column name
  geneList <- df[[fc_col]]
  names(geneList) <- entrez_ids[df[[gene_col]]]
  geneList <- na.omit(geneList)
  
  # Sort geneList in decreasing order
  geneList <- sort(geneList, decreasing = TRUE)
  
  # Perform GSEA
  set.seed(1)
  enrich <- gseGO(geneList = geneList, 
                  OrgDb = org.Hs.eg.db, 
                  ont = ont, 
                  minGSSize = 10,
                  maxGSSize = 500,
                  pvalueCutoff = 0.05,
                  verbose = FALSE)
  
  return(enrich)
}

# Function to extract top GO terms from the results
extract_top_go_terms <- function(enrich, n) {
  result <- as.data.frame(enrich)
  result <- result %>%
    arrange(pvalue) %>%
    slice_head(n = n)
  
  result$direction <- ifelse(result$NES > 0, "Up", "Down")
  
  return(result)
}

# Function to create a combined dataframe with GO terms, gene ratios, and gene lists
# UPDATED: Passes column names down to perform_go_enrichment
create_combined_df <- function(df, ont_list, n, gene_col, fc_col) {
  result_df <- data.frame()
  
  for (ont in ont_list) {
    # Pass the column names here
    enrich <- perform_go_enrichment(df, ont, gene_col, fc_col)
    
    # Check if enrich is NULL or empty before proceeding
    if (is.null(enrich) || nrow(as.data.frame(enrich)) == 0) {
      next 
    }
    
    top_terms <- extract_top_go_terms(enrich, n)
    
    top_terms$ont <- ont
    top_terms$gene_ratio <- top_terms$setSize / nrow(df)
    top_terms$gene_count <- top_terms$setSize
    
    result_df <- rbind(result_df, top_terms)
  }
  
  return(result_df)
}

# Clustering function (Unchanged)
cluster_go_terms <- function(go_data, h = 0.9) {
  print("Starting clustering...")
  
  if (nrow(go_data) == 0) {
    print("No GO terms to cluster.")
    return(data.frame(ID = character(0), cluster = integer(0)))
  }
  
  print(paste("Number of GO terms:", nrow(go_data)))
  
  # Extract GO terms and their associated gene lists
  go_terms <- go_data$ID
  genes_list <- strsplit(go_data$core_enrichment, "/")
  
  print(paste("Number of gene lists:", length(genes_list)))
  
  # Filter out GO terms with no genes
  valid_indices <- sapply(genes_list, function(gene_data) !is.null(gene_data) && length(gene_data) > 0)
  valid_go_terms <- go_terms[valid_indices]
  valid_genes_list <- genes_list[valid_indices]
  
  print(paste("Number of valid GO terms:", length(valid_go_terms)))
  
  # If no valid GO terms, return an empty dataframe
  if (length(valid_go_terms) == 0) {
    print("No valid GO terms found. Returning empty dataframe.")
    return(data.frame(ID = character(0), cluster = integer(0)))
  }
  
  # Define Jaccard similarity function
  jaccard_similarity <- function(set1, set2) {
    intersection <- length(intersect(set1, set2))
    union <- length(union(set1, set2))
    return(intersection / union)
  }
  
  # Initialize similarity matrix
  n <- length(valid_go_terms)
  similarity_matrix <- matrix(0, nrow = n, ncol = n, dimnames = list(valid_go_terms, valid_go_terms))
  
  # Calculate pairwise Jaccard similarities
  for (i in 1:n) {
    for (j in i:n) {
      sim <- jaccard_similarity(valid_genes_list[[i]], valid_genes_list[[j]])
      similarity_matrix[i, j] <- sim
      similarity_matrix[j, i] <- sim  # Symmetric matrix
    }
  }
  
  # Convert similarity matrix to distance matrix (1 - similarity)
  distance_matrix <- 1 - similarity_matrix
  
  # Perform hierarchical clustering
  hc <- hclust(as.dist(distance_matrix), method = "average")
  
  # Cut the dendrogram into clusters
  clusters <- cutree(hc, h = h)
  
  # Return dataframe with valid GO terms and their clusters
  result_df <- data.frame(ID = valid_go_terms, cluster = clusters)
  
  print(paste("Number of clusters:", length(unique(clusters))))
  print("Clustering completed.")
  
  return(result_df)
}

# Plotting function (Unchanged)
plot_go_enrichment <- function(df, font_size = 8, legend_size = 12, cluster_dot_size = 8, title = NULL) {
  # Check for required columns
  required_cols <- c("ID", "Description", "pvalue", "ont", "direction", "gene_ratio", "gene_count", "cluster")
  missing_cols <- setdiff(required_cols, colnames(df))
  if (length(missing_cols) > 0) {
    stop(paste("Missing required columns:", paste(missing_cols, collapse = ", ")))
  }
  
  # Ensure all required columns are present and non-null
  df <- df %>%
    filter(!is.na(ID) & !is.na(Description) & !is.na(pvalue) & 
             !is.na(ont) & !is.na(direction) & !is.na(gene_ratio) & 
             !is.na(gene_count) & !is.na(cluster))
  
  # Generate a color palette based on the number of clusters
  n_clusters <- length(unique(df$cluster))
  color_palette <- scales::hue_pal()(n_clusters)
  
  # Create labels with p-value formatting and asterisks
  df$label <- sapply(1:nrow(df), function(i) {
    pval <- df$pvalue[i]
    pval_formatted <- formatC(pval, format = "e", digits = 2)
    stars <- ""
    if (pval < 0.001) {
      stars <- '<span style="font-family: mono;">***</span>'
    } else if (pval < 0.01) {
      stars <- '<span style="font-family: mono;">** </span>'
    } else if (pval < 0.05) {
      stars <- '<span style="font-family: mono;"> * </span>'
    }
    paste0(df$Description[i], " - ", df$ID[i], " - p-val: ", pval_formatted, " ", stars)
  })
  
  # Rank by cluster, then by descending NES value
  df <- df %>%
    arrange(cluster, abs(NES)) %>%
    mutate(rank = row_number())
  
  # Create the plot
  p <- ggplot(df, aes(x = abs(NES), y = reorder(label, rank))) +
    geom_point(aes(color = factor(cluster), size = gene_count), shape = 21, stroke = 0.9, fill = NA) +  # Outline
    geom_point(aes(color = factor(cluster), size = gene_count), alpha = 0.7) +  # Filled dot
    geom_text(aes(label = cluster), size = 2.5, color = "white", fontface = "bold", show.legend = FALSE) +  # Cluster number
    facet_grid(ont ~ direction, scales = "free_y", space = "free_y") +
    scale_color_manual(values = color_palette) +
    scale_size_continuous(range = c(2, 10)) +
    scale_x_continuous(limits = c(0, NA)) +  # Set x-axis to start from 0
    theme_bw() +
    theme(
      axis.text.y = ggtext::element_markdown(size = font_size),
      legend.title = element_text(size = legend_size),
      legend.text = element_text(size = legend_size),
      legend.key.size = unit(cluster_dot_size, "mm")
    ) +
    guides(
      color = guide_legend(override.aes = list(size = cluster_dot_size))
    ) +
    labs(x = "Absolute NES", y = "GO Term", color = "Cluster", size = "Gene Count", 
         title = title)  # Add the user-provided title
  
  return(p)
}

# Main workflow function
# UPDATED: Accepts 'gene_col' and 'fc_col' and passes them to create_combined_df
main_workflow <- function(df, ont_list = c("BP", "CC", "MF"), n = 20, h = 0.95, title = NULL, gene_col, fc_col) {
  
  # Perform enrichment analysis with variable columns
  enrichment_results <- create_combined_df(df, ont_list, n, gene_col, fc_col)
  
  if(nrow(enrichment_results) == 0) {
    print(paste("No significant terms found for:", title))
    return(NULL)
  }

  # Perform clustering
  clustered_results <- cluster_go_terms(enrichment_results, h)
  
  # Merge enrichment and clustering results
  final_results <- merge(enrichment_results, clustered_results, by = "ID", all.x = TRUE)
  
  # Create the plot
  go_plot <- plot_go_enrichment(final_results, font_size = 10, title = title)
  
  # Print the plot to the R plotting environment
  print(go_plot)
  
  return(list(results = final_results, plot = go_plot))
}

# --- EXECUTION LOOP ---

# Prepare the dataframes in a named list
df_list <- list(
  "ISS_Surface_vs_Core" = dge_iss,
  "WTD_Surface_vs_Core" = dge_wtd
)

# Prepare the specific column names for each dataset
# NOTE: Ensure "log2FoldChange_ISS" matches the actual CSV column for the ISS file.
#       If it is "avg_log2FC" or similar, update it here.
fc_cols <- list(
  "ISS_Surface_vs_Core" = "log2FoldChange_ISS", 
  "WTD_Surface_vs_Core" = "log2FoldChange_WTD"
)

# Loop over dataset list and apply the workflow
for (df_name in names(df_list)) {
  
  dataset <- df_list[[df_name]]
  fc_col_name <- fc_cols[[df_name]]
  
  # Create title
  title <- paste("GO Term Enrichment:", gsub("_", " ", df_name))
  cat("\nProcessing:", title, "using column:", fc_col_name, "\n")
  
  # Run the workflow with the specific column names
  main_workflow(df = dataset, 
                title = title, 
                gene_col = "gene",        # Both files use "gene"
                fc_col = fc_col_name)     # Varies by file
}
```