---
output:
  pdf_document:
    latex_engine: xelatex
geometry: margin=0.2in
---

# 1. Load files & Libraries
```{r setup, include=FALSE, message = FALSE, warning = FALSE}
# Load config.R & Set dir
source("config.R")
knitr::opts_knit$set(root.dir = data_dir)

# Figures Folder
fig_subdir <- file.path(figs_dir, "0.1.1")
if(!dir.exists(fig_subdir)) dir.create(fig_subdir, recursive = TRUE)

# Load libraries
library(tidyverse) # CRAN
library(Matrix) # CRAN
library(ggplot2) # CRAN
library(data.table) # CRAN
library(Seurat) # CRAN
library(dplyr) # CRAN
library(viridis) # CRAN
library(sctransform) # CRAN
library(RANN) # CRAN
library(scry) # bioconductor
library(SingleCellExperiment) # bioconductor
```
```{r}
# Load Data
wts_obj <- readRDS(file = "janesick_2023/raw_clean/wts_obj_clean.RDS")
```


# 2. Quality Control

```{r}
# Calculate QC metrics
wts_obj[["percent.mt"]] <- PercentageFeatureSet(wts_obj, pattern = "^MT-") # perc. gene expression attributed to MT genes
wts_obj$log1p_nCount_RNA <- log1p(wts_obj$nCount_RNA)
wts_obj$log1p_nFeature_RNA <- log1p(wts_obj$nFeature_RNA)

# Calculate pct counts in top 20 genes for each cell (complexity metric)
gene_sums <- rowSums(GetAssayData(wts_obj, assay = "RNA", layer = "counts"))
top20_genes <- names(sort(gene_sums, decreasing = TRUE)[1:20])
top20_counts <- colSums(wts_obj@assays$RNA$counts[top20_genes, ])
wts_obj$pct_counts_top20genes <- (top20_counts / wts_obj$nCount_RNA) * 100
```

```{r, fig.width=7.87, dpi=300, dev='tiff', out.width='100%'}
# 1. Histogram of nCount_RNA
p1 <- ggplot(wts_obj@meta.data, aes(x = nCount_RNA)) +
  geom_histogram(bins = 150, fill = "steelblue", color = 'black', linewidth = 0) +
  theme_minimal() +
  labs(title = "Distribution of Total Counts", x = "total counts", y = "Frequency")+
  theme(
    plot.title = element_text(size = 14),
    axis.title = element_text(size = 12),
    axis.text  = element_text(size = 11)); p1

# 2. Violin plot of percentage mitochondrial genes
p2 <- ggplot(wts_obj@meta.data, aes(x = Annotation, y = percent.mt, fill = Cancerous)) +
  geom_violin(trim = FALSE, alpha = 0.7) +
  geom_jitter(width = 0.2, size = 1, shape = 46, alpha = 0.5, color = "black") +  # points in black
  scale_fill_manual(values = c("TRUE" = "#E6893D", "FALSE" = "steelblue")) +
  theme_minimal() +
  labs(x = "Annotation", y = "Percent MT") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)); p2

# 3. Scatter plot of three metrics together
p3 <- ggplot(wts_obj@meta.data, aes(x = nCount_RNA, y = nFeature_RNA, color = Annotation)) +
  geom_point(alpha = 0.6, size = 1) +
  theme_minimal() +
  scale_x_log10() +
  scale_y_log10() +
  scale_color_viridis_d(option = "turbo") +
  labs (title = 'Seq. depth vs num. detected genes coloured by cell type',
        x = 'nCount_RNA',
        y = 'nFeature_RNA',
        color = 'Annotation'); p3

ggsave(filename = file.path(fig_subdir, "p1_dist_total_counts.png"), plot = p1, dpi = 300)
ggsave(filename = file.path(fig_subdir, "p2_pct_MT_genes.png"), plot = p2, dpi = 300)
ggsave(filename = file.path(fig_subdir, "p3_seq_depth_vs_num_detected_genes.png"), plot = p3, dpi = 300)
```
#### Filtering low quality cells
```{r}
# Define function to detect outliers using MAD
is_outlier <- function(metric, nmads) {  
  med_val <- median(metric, na.rm = TRUE)
  mad_val <- mad(metric, na.rm = TRUE)
  return((metric < (med_val - nmads * mad_val)) | (metric > (med_val + nmads * mad_val)))
}

# Identify Outliers
outliers_df <- wts_obj@meta.data %>%
  rownames_to_column("barcode") %>%
  group_by(Annotation) %>%
  mutate(
    outlier_nCount   = is_outlier(log1p_nCount_RNA, 5),
    outlier_nFeature = is_outlier(log1p_nFeature_RNA, 5),
    outlier_top20    = is_outlier(pct_counts_top20genes, 5),
    outlier_mt_mad   = is_outlier(percent.mt, 3),
    outlier_mt_abs   = percent.mt > 8,
    any_outlier      = outlier_nCount | outlier_nFeature | outlier_top20 | outlier_mt_mad | outlier_mt_abs
  ) %>%
  ungroup()

# Add Cancerous column
outliers_df$Cancerous <- wts_obj$Cancerous[match(outliers_df$barcode, colnames(wts_obj))]

# Summarise per Annotation
summary_table <- outliers_df %>%
  group_by(Annotation) %>%
  summarise(
    Cancerous = unique(Cancerous),
    n_cells = n(),
    n_outliers = sum(any_outlier),
    pct_outliers = round(mean(any_outlier) * 100, 2),
    outlier_nCount = sum(outlier_nCount),
    outlier_nFeature = sum(outlier_nFeature),
    outlier_top20 = sum(outlier_top20),
    outlier_mt_mad = sum(outlier_mt_mad),
    outlier_mt_abs = sum(outlier_mt_abs)
  ) %>%
  arrange(desc(Cancerous))
print(summary_table)

# Filter out outliers
cells_to_keep <- outliers_df$barcode[!outliers_df$any_outlier]
wts_obj <- subset(wts_obj, cells = cells_to_keep)
```
#### Remove ambient genes
```{r}
# To be added later
```

#### Remove doublets
```{r}
# To be added later
```

#### Subsample to n cells for quicker processing (Comment out when using full dataset)
```{r}
# # Random subsampling to n cells per cell type
# # extract metadata
# meta <- wts_obj@meta.data %>%
#   rownames_to_column(var = 'cell')
# 
# set.seed(123)
# sampled_cells <- meta %>%
#   group_by(Annotation) %>%
#   slice_sample(n = wts_params$n_subsamples) %>%
#   pull(cell)
# 
# # Subset the Seurat object to those cell names
# wts_obj <- subset(wts_obj, cells = sampled_cells)
```

# 2. Normalisation & Feature Selection  

```{r}
# 1. Normalise Data (Standard log-normalisation)
wts_obj <- NormalizeData(wts_obj)

# 2. Compute Binomial Deviance on Raw Counts
sce <- as.SingleCellExperiment(wts_obj, assay = 'RNA')
print(assayNames(sce))
sce <- devianceFeatureSelection(sce, assay = "counts")

# 3. Extract Deviance and Rank
bin_dev <- rowData(sce)$binomial_deviance
names(bin_dev) <- rownames(sce)
wts_obj[["RNA"]][["binomial_deviance"]] <- bin_dev

# 4. Define Variable Features (Top 4000)
top_4000 <- names(sort(bin_dev, decreasing = TRUE)[1:4000])
VariableFeatures(wts_obj) <- top_4000

# 5. Create Metadata for Plotting
is_highly_deviant <- rownames(wts_obj) %in% top_4000
names(is_highly_deviant) <- rownames(wts_obj)
wts_obj[["RNA"]][["highly_deviant"]] <- is_highly_deviant

# 6. Scale Data (Now that VariableFeatures are set)
wts_obj <- ScaleData(wts_obj, features = VariableFeatures(wts_obj))
```

#### Visualise Feature Selection results
```{r, fig.width=7.87, dpi=300, dev='tiff', out.width='100%'}
#calculate mean expression / dispersion (using normalised data)
norm_counts <- GetAssayData(wts_obj, layer = "data", assay = "RNA")
gene_means <- Matrix::rowMeans(norm_counts)
gene_vars <- Matrix::rowMeans(norm_counts^2) - gene_means^2
gene_dispersions <- gene_vars / gene_means

# create a df for plotting
plot_data <- data.frame(
  gene = rownames(wts_obj),
  means = gene_means,
  dispersions = gene_dispersions,
  highly_deviant = wts_obj[["RNA"]][["highly_deviant"]]
)

ggplot(plot_data, aes(x = means, y = dispersions, color = highly_deviant)) +
  geom_point(size = 0.5, alpha = 0.6) +
  scale_color_manual(values = c("FALSE" = "lightgray", "TRUE" = "red")) +
  xlim(0, 1.5) + ylim(0, 3) +
  labs(title = "Gene Selection by Deviance", x = "Mean Expression", y = "Dispersion") +
  theme_minimal()
```

# 3. Dimensionality Reduction

```{r, fig.width=7.87, dpi=300, dev='tiff', out.width='100%'}
#PCA
wts_obj <- RunPCA(wts_obj, features = VariableFeatures(wts_obj), verbose = F)
ElbowPlot(wts_obj, ndims = 50, reduction = 'pca')

# PCA Plot
DimPlot(wts_obj, reduction = "pca", group.by = "Annotation") + ggtitle("PCA")

# Neighbors & Clusters (Required for UMAP structure usually)
wts_obj <- FindNeighbors(wts_obj, dims = wts_params$dims, reduction = "pca", verbose = FALSE)

# t-SNE
wts_obj <- RunTSNE(wts_obj, dims = wts_params$dims, reduction = "pca", verbose = FALSE)
DimPlot(wts_obj, reduction = "tsne", group.by = "Annotation") + ggtitle("t-SNE")

# UMAP
wts_obj <- RunUMAP(wts_obj, dims = wts_params$dims, reduction = "pca", verbose = FALSE)
DimPlot(wts_obj, reduction = "umap", group.by = "Annotation") + ggtitle("UMAP")
```

# 4. Save processed object
```{r}
saveRDS(wts_obj, file = file.path(data_dir, "janesick_2023/processed/wts_obj_processed.RDS"))
```



#### Clustering Invasive Tumour Cells ####
```{r}
#### Clustering Invasive Tumour Cells ####

# 1. Subset the object
# Note: Ensure "Invasive_Tumor" matches your exact factor level in Annotation
invasive_obj <- subset(wts_obj, subset = Annotation == "Invasive_Tumor")

# 2. Re-run Feature Selection 
# We do this because genes that were variable across the whole tissue 
# might not be the ones that distinguish tumor subtypes.
sce_inv <- as.SingleCellExperiment(invasive_obj, assay = 'RNA')
sce_inv <- devianceFeatureSelection(sce_inv, assay = "counts")
bin_dev_inv <- rowData(sce_inv)$binomial_deviance
VariableFeatures(invasive_obj) <- names(sort(bin_dev_inv, decreasing = TRUE)[1:2000])

# 3. Re-scale and Re-run PCA
invasive_obj <- ScaleData(invasive_obj, features = VariableFeatures(invasive_obj))
invasive_obj <- RunPCA(invasive_obj, verbose = FALSE)

# 4. Find Neighbors and Clusters
# Adjust resolution as needed; higher resolution = more clusters
invasive_obj <- FindNeighbors(invasive_obj, dims = 1:20)
invasive_obj <- FindClusters(invasive_obj, resolution = 0.1)

# 5. Run UMAP on the new PCA
invasive_obj <- RunUMAP(invasive_obj, dims = 1:20)

# 6. Visualise
p_inv <- DimPlot(invasive_obj, reduction = "umap", label = TRUE) + 
  ggtitle("UMAP: Invasive Tumour Sub-clusters")
p_inv

# Optional: Save the sub-object
# saveRDS(invasive_obj, file = file.path(data_dir, "janesick_2023/processed/invasive_tumor_subset.RDS"))
```

```{r}
# Ensure identity is set to the new clusters
Idents(invasive_obj) <- "seurat_clusters"

# Find markers for all clusters (Pre-filter to speed up)
tumor_markers <- FindAllMarkers(
  invasive_obj, 
  only.pos = TRUE, 
  min.pct = 0.25, 
  logfc.threshold = 0.25
)

# View top 5 markers per cluster
top5_markers <- tumor_markers %>%
  group_by(cluster) %>%
  slice_max(n = 5, order_by = avg_log2FC)

print(top5_markers)
```

```{r}
library(clusterProfiler)
library(org.Hs.eg.db) # Use org.Mm.eg.db for mouse
library(enrichplot)

# 1. Get all genes and their logFC for every cluster 
# Set thresholds to 0 to get a complete list for GSEA ranking
all_genes_markers <- FindAllMarkers(
  invasive_obj, 
  only.pos = FALSE, 
  min.pct = 0, 
  logfc.threshold = 0, 
  verbose = TRUE
)

# 2. Prepare a list of ranked gene vectors for compareCluster
# We rank by avg_log2FC (or a combined score of -log10(p_val) * log2FC)
gene_list_clusters <- all_genes_markers %>%
  split(.$cluster) %>%
  map(~ {
    # Create the ranked vector
    rank_vec <- .x$avg_log2FC
    names(rank_vec) <- .x$gene
    sort(rank_vec, decreasing = TRUE)
  })
```

```{r}
# 3. Run GSEA using GO (Biological Process)
# Note: 'gseGO' is a wrapper that handles the GSEA algorithm
ck <- compareCluster(
  geneClusters = gene_list_clusters, 
  fun = "gseGO", 
  ont = "BP", 
  OrgDb = org.Hs.eg.db, 
  keyType = "SYMBOL",
  pvalueCutoff = 0.05
)

# 4. Simplify to remove redundant GO terms
ck_simple <- simplify(ck)
```

```{r}
# Visualise the top 3 pathways per cluster
dotplot(ck, showCategory = 4) + 
  scale_color_viridis_c(guide = guide_colorbar(reverse = TRUE)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "GSEA Biological Processes by Cluster")
```

test