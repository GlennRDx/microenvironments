---
output:
  pdf_document:
    latex_engine: xelatex
geometry: margin=0.2in
---

# 1. Load libraries and data
```{r setup, include=FALSE, message = FALSE, warning = FALSE}
# Load config.R
source("config.R") 

# Set root directory using the variable from config
knitr::opts_knit$set(root.dir = data_dir)

# Define figure directory
fig_subdir <- file.path(figs_dir, "0.5.2")
if(!dir.exists(fig_subdir)) dir.create(fig_subdir, recursive = TRUE)

library(Seurat)
library(dplyr)
library(EnhancedVolcano)
library(clusterProfiler)
library(topGO)
library(org.Hs.eg.db)
library(ggplot2)
library(enrichplot)
library(tidyverse)
library(ggtext)
library(scales)
```

```{r}
# Load data
wts_obj <- readRDS("janesick_2023/processed/wts_obj_processed_predicted.RDS")
```

# 2. DGE Analysis
```{r, warning = FALSE}
Idents(wts_obj) <- "microenv_prediction"

# Find markers comparing Surface (ident.1) vs Core (ident.2)
dge_results_negbinom <- FindMarkers(
  object = wts_obj,
  slots = "counts",
  ident.1 = "Surface",
  ident.2 = "Core",
  test.use = "negbinom",
  logfc.threshold = 0,
  min.pct = 0
)

# dge_results_wilcoxon <- FindMarkers(
#   object = wts_obj,
#   ident.1 = "Surface",
#   ident.2 = "Core",
#   test.use = "wilcox",
#   logfc.threshold = 0,
#   min.pct = 0
# )
```

```{r}
# DGE results table
dge_results_negbinom$result <- ifelse(dge_results_negbinom$p_val_adj < 0.05 & dge_results_negbinom$avg_log2FC > 1, "Up",
               ifelse(dge_results_negbinom$p_val_adj < 0.05 & dge_results_negbinom$avg_log2FC < -1, "Down", 
                 "Other"))


# dge_results_wilcoxon$result <- ifelse(dge_results_wilcoxon$p_val_adj < 0.05 & dge_results_wilcoxon$avg_log2FC > 1, "Up",
#                ifelse(dge_results_wilcoxon$p_val_adj < 0.05 & dge_results_wilcoxon$avg_log2FC < -1, "Down", 
#                  "Other"))
```

# 3. Volcano Plot

```{r}
# Plot
plot(dge_results_negbinom$avg_log2FC, 
     -log10(dge_results_negbinom$p_val_adj),
     col = ifelse(dge_results_negbinom$result == "Other", "black", "red"),
     main = "Surface vs. Core (negbinom)", 
     xlab = "log2 Fold Change", 
     ylab = "-log10(adj p-value)",
     pch = 16, cex = 0.5)
abline(h = -log10(0.05), col = "black", lty = 2) # Horizontal p-adj line
abline(v = c(-1, 1), col = "black", lty = 2) # Vertical FC lines

# plot(dge_results_wilcoxon$avg_log2FC, -log10(dge_results_wilcoxon$p_val_adj),
#      col = ifelse(dge_results_wilcoxon$result == "Other", "black", "red"),
#      main = "Surface vs. Core (wilcoxon)",
#      xlab = "log2 Fold Change",
#      ylab = "-log10(adj p-value)",
#      pch = 16, cex = 0.5)
# abline(h = -log10(0.05), col = "black", lty = 2) # Horizontal p-adj line
# abline(v = c(-1, 1), col = "black", lty = 2) # Vertical FC lines
```

# 4. GSEA w/ clusterProfiler
```{r, fig.width=7.87*2, fig.height = 6.5*2, dpi=300, dev='tiff', out.width='100%'}
# Create ranked gene list (rank metric is sign(log2FC multiplied by -log10(p-adj)))
dge_results_negbinom$ranking_metric <- sign(dge_results_negbinom$avg_log2FC) * -log10(dge_results_negbinom$p_val_adj)

dge_results_negbinom <- dge_results_negbinom[order(dge_results_negbinom$ranking_metric, decreasing = T),]

gene_list <- dge_results_negbinom$ranking_metric
names(gene_list) <- rownames(dge_results_negbinom)


# GSEA w/ GO terms
.gsea_BP <- gseGO(
  geneList     = gene_list,
  OrgDb        = org.Hs.eg.db,
  keyType      = "SYMBOL",
  ont          = "BP",
  minGSSize    = 10,
  maxGSSize    = 500,
  pvalueCutoff = 0.05,
  verbose      = FALSE
)
gsea_BP <- as.data.frame(.gsea_BP)
# gsea_BP$core_enrichment <- strsplit(gsea_BP$core_enrichment, "/")
gsea_BP$Class <- "BP"

.gsea_MF <- gseGO(
  geneList     = gene_list,
  OrgDb        = org.Hs.eg.db,
  keyType      = "SYMBOL",
  ont          = "MF",
  minGSSize    = 10,
  maxGSSize    = 500,
  pvalueCutoff = 0.05,
  verbose      = FALSE
)
gsea_MF <- as.data.frame(.gsea_MF)
# gsea_MF$core_enrichment <- strsplit(gsea_MF$core_enrichment, "/")
gsea_MF$Class <- "MF"

.gsea_CC <- gseGO(
  geneList     = gene_list,
  OrgDb        = org.Hs.eg.db,
  keyType      = "SYMBOL",
  ont          = "CC",
  minGSSize    = 10,
  maxGSSize    = 500,
  pvalueCutoff = 0.05,
  verbose      = FALSE
)
gsea_CC <- as.data.frame(.gsea_CC)
# gsea_CC$core_enrichment <- strsplit(gsea_CC$core_enrichment, "/")
gsea_CC$Class <- "CC"

gsea_full <- rbind(gsea_BP, gsea_MF, gsea_CC)
```

```{r}
# 1. Plot using the GO ID (the most precise way)
gseaplot2(.gsea_BP, 
          geneSetID = "GO:0070482",
          title = "Response to oxygen levels",
          pvalue_table = TRUE)

gseaplot2(.gsea_BP, 
          geneSetID = "GO:0036296",
          title = "Response to increased oxygen levels",
          pvalue_table = TRUE)

gseaplot2(.gsea_BP, 
          geneSetID = "GO:0001666",
          title = "Response to hypoxia",
          pvalue_table = TRUE)

# 2. Plot using the row index (useful for looking at your top result)
gseaplot2(.gsea_BP, 
          geneSetID = 1,
          ES_geom = "line")
```

```{r}
# 1. Extract genes into a list (assuming they are "/" or "," delimited)
gene_list <- strsplit(gsea_full$core_enrichment, "[/,]")
gsea_full$genes <- sapply(gene_list, paste, collapse = ",")

# 2. Create Jaccard distance matrix
n <- nrow(gsea_full)
dist_mat <- matrix(0, nrow = n, ncol = n)

for (i in 1:n) {
  for (j in i:n) {
    intersection <- length(intersect(gene_list[[i]], gene_list[[j]]))
    union <- length(union(gene_list[[i]], gene_list[[j]]))
    # Convert similarity to distance
    dist_mat[i, j] <- dist_mat[j, i] <- 1 - (intersection / union)
  }
}

# 3. Cluster and add back to data table
# Using a fixed height (h) for the tree cut; adjust 0.7 to change cluster granularity
hc <- hclust(as.dist(dist_mat), method = "complete")
gsea_full$cluster <- cutree(hc, h = 0.7)
```


```{r}
# hierarchical clustering to counteract gene set redundancy
cluster_go_terms <- function(df, h = 0.9) {
  message("Starting clustering...")
  
  # Validation: Check if dataframe is empty
  if (nrow(df) == 0) {
    warning("Input dataframe is empty. Returning original dataframe.")
    return(df)
  }
  
  # 1. Prepare Gene Lists
  # The user specified 'core_enrichment' contains a list of genes. 
  # We ensure it is in the correct format (list of character vectors).
  genes_list <- df$core_enrichment
  
  # Logic check: If core_enrichment is a single string with "/" separators (common in clusterProfiler),
  # split it. Otherwise, assume it is already a list object.
  if (is.character(genes_list[[1]]) && length(genes_list[[1]]) == 1 && grepl("/", genes_list[[1]])) {
     genes_list <- strsplit(genes_list, "/")
  }

  # Filter out invalid entries (empty gene lists)
  valid_indices <- sapply(genes_list, function(x) length(x) > 0)
  if (sum(valid_indices) < 2) {
    message("Not enough valid terms to cluster. Assigning all to Cluster 1.")
    df$cluster <- 1
    return(df)
  }
  
  # Subset to valid terms for calculation
  valid_genes_list <- genes_list[valid_indices]
  
  # 2. Define Jaccard Similarity Function
  get_jaccard <- function(set1, set2) {
    intersection <- length(intersect(set1, set2))
    union <- length(union(set1, set2))
    return(intersection / union)
  }
  
  # 3. Compute Similarity Matrix
  n <- length(valid_genes_list)
  sim_matrix <- matrix(0, nrow = n, ncol = n)
  
  # Calculate pairwise similarities
  # (This can be slow for very large n, but robust for typical GO results)
  for (i in 1:n) {
    for (j in i:n) {
      sim <- get_jaccard(valid_genes_list[[i]], valid_genes_list[[j]])
      sim_matrix[i, j] <- sim
      sim_matrix[j, i] <- sim
    }
  }
  
  # 4. Hierarchical Clustering
  # Convert to distance (1 - similarity)
  dist_matrix <- as.dist(1 - sim_matrix)
  
  # Cluster using average linkage
  hc <- hclust(dist_matrix, method = "average")
  
  # Cut tree to define clusters
  # h = height cutoff (0.9 means terms must be very dissimilar to be separate)
  clusters <- cutree(hc, h = h)
  
  # 5. Assign Clusters back to Dataframe
  # Initialize cluster column with NA
  df$cluster <- NA
  # Assign calculated clusters to the valid rows
  df$cluster[valid_indices] <- clusters
  
  # Fill any remaining NAs (invalid rows) with 0 or a placeholder
  df$cluster[is.na(df$cluster)] <- 0
  
  message(paste("Clustering completed. Identified", length(unique(clusters)), "distinct clusters."))
  return(df)
}

# 2. Visualization Function
plot_go_enrichment <- function(df, title = "GO Enrichment Analysis") {
  
  # A. Data Preparation for Plotting
  plot_df <- df %>%
    filter(!is.na(cluster)) %>%
    mutate(
      # Create Direction column based on NES
      direction = ifelse(NES > 0, "Up", "Down"),
      # Ensure Class is a factor (optional, helps ordering)
      Class = factor(Class, levels = c("BP", "CC", "MF")), 
      # Create significance labels
      significance = case_when(
        pvalue < 0.001 ~ "***",
        pvalue < 0.01  ~ "**",
        pvalue < 0.05  ~ "*",
        TRUE           ~ ""
      )
    )
  
  # Create the formatted Y-axis label (HTML style for ggtext)
  # Format: "Description - p-val: X.XXe-Y ***"
  plot_df$label_text <- paste0(
    plot_df$Description, 
    " <span style='color:#666666; font-size:8pt'> (p: ", 
    formatC(plot_df$pvalue, format = "e", digits = 2), 
    " ", plot_df$significance, ")</span>"
  )
  
  # Sorting: Group by Class -> Direction -> Cluster -> NES
  plot_df <- plot_df %>%
    group_by(Class, direction) %>%
    arrange(cluster, abs(NES)) %>%
    ungroup() %>%
    mutate(rank_order = row_number()) # Helper for fixing Y-axis order
  
  # B. Generate Palette
  n_clusters <- length(unique(plot_df$cluster))
  # Use a distinct color palette
  cluster_colors <- scales::hue_pal()(n_clusters)
  
  # C. Plotting
  p <- ggplot(plot_df, aes(x = abs(NES), y = reorder(label_text, rank_order))) +
    
    # 1. The Bubbles
    geom_point(aes(size = setSize, fill = factor(cluster)), 
               shape = 21,    # Filled circle with outline
               color = "white", # White outline
               stroke = 0.5,
               alpha = 0.8) +
    
    # 2. Cluster Number Text inside bubbles (optional, good for large clusters)
    geom_text(aes(label = cluster), 
              color = "white", 
              size = 3, 
              fontface = "bold",
              check_overlap = TRUE) +
    
    # 3. Faceting
    facet_grid(Class ~ direction, scales = "free_y", space = "free_y") +
    
    # 4. Scales and Styling
    scale_fill_manual(values = cluster_colors, name = "Cluster") +
    scale_size_continuous(range = c(3, 10), name = "Gene Count") +
    labs(
      title = title,
      x = "Absolute Normalized Enrichment Score (NES)",
      y = NULL # Y label is redundant with text
    ) +
    theme_bw() +
    theme(
      # Enable HTML rendering for the Y-axis labels
      axis.text.y = element_markdown(size = 10),
      strip.background = element_rect(fill = "#f0f0f0"),
      strip.text = element_text(face = "bold"),
      panel.grid.minor = element_blank()
    )
  
  return(p)
}
```

```{r}
# Cluster GO results
go_ids <- gsea_full$ID

gene_map <- AnnotationDbi::select(org.Hs.eg.db, 
                   keys = go_ids, 
                   columns = c("SYMBOL", "ENTREZID"), 
                   keytype = "GOALL")

gsea_full_filt <- gsea_full[gsea_full$qvalue < 0.05,]

# run script
clustered_df <- cluster_go_terms(gsea_full, h = 0.9)

# edit df and plot
# clustered_df_filt <- clustered_df[clustered_df$cluster_size >= 10,]
final_plot <- plot_go_enrichment(clustered_df, title = "Clustered GO Terms")

clustered_df$cluster_size <- ave(seq_along(clustered_df$cluster), clustered_df$cluster, FUN = length)

print(final_plot)
```