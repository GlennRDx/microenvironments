---
output:
  pdf_document:
    latex_engine: xelatex
geometry: margin=0.2in
---

# 1. Load files & Libraries
```{r setup, include=FALSE, message = FALSE, warning = FALSE}
# Load config.R
source("config.R") 

# Set root directory using the variable from config
knitr::opts_knit$set(root.dir = data_dir)

# Figures Folder
fig_subdir <- file.path(figs_dir, "0.2.1")
if(!dir.exists(fig_subdir)) dir.create(fig_subdir, recursive = TRUE)

# Load libraries
library(tidyverse, quietly = T) # CRAN
library(data.table, quietly = T) # CRAN
library(Seurat, quietly = T) # CRAN
library(viridis, quietly = T) # CRAN
library(RANN, quietly = T) # CRAN
library(paletteer)
library(EnhancedVolcano)
library(clusterProfiler)
library(org.Hs.eg.db)
```
```{r}
# Load data
iss_expr <- readRDS("janesick_2023/raw_clean/iss_expr_clean.RDS")
iss_meta <- readRDS("janesick_2023/raw_clean/iss_meta_clean.RDS")
setDT(iss_meta) # Set to data.table for speed
```

# 2. Radius Method
```{r}
start_time <- Sys.time()

# 1. Prep coordinates
coords <- iss_meta[, .(x_centroid, y_centroid)]

# 2. Perform radius search (returns the indices)
nn_result <- nn2(data = coords, query = coords, searchtype = "radius", radius = iss_params$radius, k = 200)

# 3. Identify target cell indices (invasice tumour cells)
invasive_idx <- which(iss_meta$Annotation == "Invasive_Tumor")
is_tumour_neighbour <- iss_meta$Annotation %in% c("Invasive_Tumor", "Prolif_Invasive_Tumor")

# 4. Calculate the fraction (vectorised for speed)
classification_vec <- vapply(invasive_idx, function(i) {
  
  nb_idx <- nn_result$nn.idx[i, ] # get the neighbour ids
  nb_idx <- nb_idx[nb_idx != 0 & nb_idx != i] # exclude self and 0 padding added by nn2
  if (length(nb_idx) == 0) return("Surface") # Edge case, if a cell has no neighbours in radius, it's a surface cell
  
  frac <- sum(is_tumour_neighbour[nb_idx]) / length(nb_idx) # Calculate Fraction
  
  if (frac > iss_params$threshold) "Core" else "Surface"
}, FUN.VALUE = character(1))

# 5. enrich metadata
iss_meta$surface_class_radius <- "Other" # Set everything to "Other"
iss_meta$surface_class_radius[invasive_idx] <- classification_vec # Overwrite "Other" with new Surface/Core classes

neighbour_counts <- rowSums(nn_result$nn.idx[invasive_idx, ] != 0) - 1
iss_meta$neighbour_count <- NA
iss_meta$neighbour_count[invasive_idx] <- neighbour_counts

end_time <- Sys.time()

cat("Classification took:", round(end_time - start_time, 2))

table(iss_meta$surface_class_radius)
```

#### Radius Method Plots
```{r, fig.width=7.87*1.75, fig.height = 6.5*1.75, dpi=300, dev='tiff', out.width='100%'}
mean_val <- mean(iss_meta$neighbour_count, na.rm = T)
p1 <- ggplot(subset(iss_meta, !is.na(neighbour_count)), aes(x = neighbour_count)) +
  geom_bar(fill = "#AA4A44", color = "black", width = 1, linewidth = 0) +
  
  # Add the vertical line for the mean
  geom_vline(aes(xintercept = mean_val), color = "black", linetype = "dashed", linewidth = 1) +
  
  theme_minimal() +
  labs(
    title = "Distribution of Counts of cells with n neighbours within radius",
    subtitle = paste("Radius =", iss_params$radius, "\nMean n =", round(mean_val, 2)),
    x = "Number of Neighbours in Radius",
    y = "Count of Cells"
  ); p1

ggsave(file.path(fig_subdir, "p1_dist_of_counts_of_cells_with_n_neighbours_in_radius.png"), plot = p1, dpi = 300)
p2 <- ggplot(iss_meta, aes(x = y_centroid, y = x_centroid, color = surface_class_radius)) +
    # Layer 1: Plot only "Other" first
    geom_point(data = subset(iss_meta, surface_class_radius == "Other"), 
               size = 0.01) +
    # Layer 2: Plot everything else on top
    geom_point(data = subset(iss_meta, surface_class_radius != "Other"), 
               size = 0.01) +
    scale_color_manual(values = c("Surface" = "#C90065", "Core" = "#fac0da", "Other" = "grey75")) +
    # Swap xlim to ylim and apply reversal to the new y-axis
    coord_fixed(ylim = c(3850, 0)) +
    theme_minimal() +
    guides(color = guide_legend(override.aes = list(size = 2))); p2

ggsave(file.path(fig_subdir, "p2_ME_annotations_radius_method.png"), plot = p2, dpi = 300)
```

# 3. KNN Method
```{r}
# 1. Get Indices
invasive_idx <- which(iss_meta$Annotation == "Invasive_Tumor")
coords_all <- as.matrix(iss_meta[, c("x_centroid", "y_centroid")])

# 2. KNN Search
nn_knn <- nn2(data = coords_all, query = coords_all[invasive_idx,], k = iss_params$knn)

# 3. Calculate Fraction
is_tumour <- iss_meta$Annotation %in% c("Invasive_Tumor", "Prolif_Invasive_Tumor")
neighbour_indices <- nn_knn$nn.idx[,-1] # remove self
perc_tumours <- rowMeans(matrix(is_tumour[neighbour_indices], nrow = nrow(neighbour_indices))) # mean of boolean vector = fraction of tumour neighbours

# 4. Assign back
iss_meta$perc_tumours <- NA_real_
iss_meta$perc_tumours[invasive_idx] <- perc_tumours

cat("KNN Classification took:", round(Sys.time() - start_time, 2))

# 5. Classify
iss_meta$surface_class_nn <- ifelse(
  is.na(iss_meta$perc_tumours), "Other",
  ifelse(iss_meta$perc_tumours < iss_params$threshold, "Surface", "Core")
)

table(iss_meta$surface_class_nn)
```

#### KNN Method Plots
```{r, fig.width=7.87*1.75, fig.height = 6.5*1.75, dpi=300, dev='tiff', out.width='100%'}
p3 <- ggplot(iss_meta, aes(x = y_centroid, y = x_centroid, color = surface_class_nn)) +
    # Layer 1: Plot only "Other" first
    geom_point(data = subset(iss_meta, surface_class_nn == "Other"), 
               size = 0.01) +
    # Layer 2: Plot everything else on top
    geom_point(data = subset(iss_meta, surface_class_nn != "Other"), 
               size = 0.01) +
    scale_color_manual(values = c("Surface" = "#C90065", "Core" = "#fac0da", "Other" = "grey75")) +
    # Swap xlim to ylim and apply reversal to the new y-axis
    coord_fixed(ylim = c(3850, 0)) +
    theme_minimal() +
    guides(color = guide_legend(override.aes = list(size = 2))); p3

ggsave(file.path(fig_subdir, "p3_ME_annotations_knn_method.png"), plot = p3, dpi = 300)
```

# 4.Tumour Cell depth Method
```{r}
iss_meta$tumour_depth <- NA_real_

#logic: Surface = 0, Core = dist to nearest Surface cell
is_surface <- iss_meta$surface_class_nn == "Surface"
is_core <- iss_meta$surface_class_nn == "Core"

iss_meta$tumour_depth[is_surface] <- 0

if (any(is_core) && any(is_surface)) {
  coords_surface <- as.matrix(iss_meta[is_surface, .(x_centroid, y_centroid)])
  coords_core <- as.matrix(iss_meta[is_core, .(x_centroid, y_centroid)])
  
  # Find nearest neighbour in "Surface" set for every "Core" cell
  nn_dist <- nn2(data = coords_surface, query = coords_core, k = 1)
  
  iss_meta$tumour_depth[is_core] <- nn_dist$nn.dists[, 1]
}

summary(iss_meta[iss_meta$surface_class_nn == "Core",]$tumour_depth)
```

#### Tumour Cell depth Method Plots
```{r, fig.width=7.87*1.75, fig.height = 6.5*1.75, dpi=300, dev='tiff', out.width='100%'}
p4 <- ggplot(iss_meta, aes(x = y_centroid, y = x_centroid)) +
    # Layer 1: Plot "Other" (NA depth) first as grey
    geom_point(data = subset(iss_meta, is.na(tumour_depth)), 
               color = "grey75",
               size = 0.01) +
    # Layer 2: Plot Tumour cells (Valid depth) on top
    geom_point(data = subset(iss_meta, !is.na(tumour_depth)), 
               aes(color = tumour_depth),
               size = 0.01) +
    # Use the same palette as your previous function
    scale_color_gradientn(colors = paletteer::paletteer_c("grDevices::Blue-Red 3", 30)) +
    # Swap xlim to ylim and apply reversal to the new y-axis
    coord_fixed(ylim = c(3850, 0)) +
    theme_minimal() +
    labs(color = "Depth"); p4

ggsave(file.path(fig_subdir, "p4_ME_annotations_depth_method.png"), plot = p4, dpi = 300)
```

#### Annotate Shallow Core Cells
```{r}
# 1. Create a new categorical column for plotting
iss_meta$depth_category <- "Other"

# 2. Assign Surface cells (Depth 0)
iss_meta$depth_category[iss_meta$surface_class_radius == "Surface"] <- "Surface"

# 3. Assign Shallow Core
# We must ensure we only pick 'Core' cells, otherwise 'Surface' (depth=0) gets overwritten
iss_meta$depth_category[iss_meta$surface_class_radius == "Core" & iss_meta$tumour_depth <= 15] <- "Shallow Core"

# 4. Assign Deep Core
iss_meta$depth_category[iss_meta$surface_class_radius == "Core" & iss_meta$tumour_depth > 15] <- "Deep Core"

# Check the counts
table(iss_meta$depth_category)
```
```{r, fig.width=7.87*1.75, fig.height = 6.5*1.75, dpi=300, dev='tiff', out.width='100%'}
p5 <- ggplot(iss_meta, aes(x = y_centroid, y = x_centroid, color = depth_category)) +
    # Layer 1: Plot only "Other" first
    geom_point(data = subset(iss_meta, surface_class_nn == "Other"), 
               size = 0.01) +
    # Layer 2: Plot everything else on top
    geom_point(data = subset(iss_meta, surface_class_nn != "Other"), 
               size = 0.01) +
    scale_color_manual(values = c("Surface" = "#C90065", "Deep Core" = "#fac0da", "Shallow Core" = "darkblue", "Other" = "grey75")) +
    # Swap xlim to ylim and apply reversal to the new y-axis
    coord_fixed(ylim = c(3850, 0)) +
    theme_minimal() +
    guides(color = guide_legend(override.aes = list(size = 2))); p5

ggsave(file.path(fig_subdir, "p5_identify_shallow_core_cells.png"), plot = p5, dpi = 300)
```

# 5. Gene Expression Clustering Method
```{r}
# 1. Create iss seurat object
iss_obj <- CreateSeuratObject(counts = iss_expr, meta.data = as.data.frame(iss_meta))
iss_obj_invasive <- subset(iss_obj, subset = Annotation == "Invasive_Tumor")
```

# Investigate Seq Depth of Cells
```{r, fig.width=7.87*3, fig.height = 6.5*3, dpi=300, dev='tiff', out.width='100%'}
pal <- colorRampPalette(c("#3c2670", "#407068", "#edd100"))(10)
# pal <- colorRampPalette(c("red", "orange", "yellow", "green", "blue", "purple", "violet"))(10)
qntls <- quantile(iss_obj_invasive$nCount_RNA, probs = seq(0, 1, length.out = 11))
cell_cols <- pal[findInterval(iss_obj_invasive$nCount_RNA, qntls, all.inside = T)]

par(bg = "black", mar = c(5, 4, 4, 8))
plot(y= iss_obj_invasive$x_centroid, x = iss_obj_invasive$y_centroid, 
     pch = 16, cex = 0.5, col = cell_cols, ylim = c(0, 4000), asp = 1)
```

```{r}
ticks <- seq(0, max(iss_obj_invasive$nCount_RNA) + 10, by = 10)
h <- hist(iss_obj_invasive$nCount_RNA, breaks = ticks, plot = F)
bar_cols <- pal[findInterval(h$mids, qntls, all.inside = T)]
plot(h, col = bar_cols)
```

# Filter out cells with low seq depth
```{r, fig.width=7.87*3, fig.height = 6.5*3, dpi=300, dev='tiff', out.width='100%'}
iss_obj_invasive <- subset(iss_obj_invasive, subset = nCount_RNA >= 50)
```

```{r, fig.width=7.87*3, fig.height = 6.5*3, dpi=300, dev='tiff', out.width='100%'}
# Plot
qntls <- quantile(iss_obj_invasive$nCount_RNA, probs = seq(0, 1, length.out = 11))
cell_cols <- pal[findInterval(iss_obj_invasive$nCount_RNA, qntls, all.inside = T)]

par(bg = "black", mar = c(5, 4, 4, 8))
plot(y= iss_obj_invasive$x_centroid, x = iss_obj_invasive$y_centroid, 
     pch = 16, cex = 0.5, col = cell_cols, ylim = c(0, 4000), asp = 1)
```

```{r}
ticks <- seq(0, max(iss_obj_invasive$nCount_RNA) + 10, by = 10)
h <- hist(iss_obj_invasive$nCount_RNA, breaks = ticks, plot = F)
bar_cols <- pal[findInterval(h$mids, qntls, all.inside = T)]
plot(h, col = bar_cols)
```

```{r}
# 2. Normalise with log1p
# raw_counts <- GetAssayData(iss_obj_invasive, assay = "RNA", layer = "counts") # extract
# log_transformed_counts <- log1p(raw_counts) # log transform
# iss_obj_invasive <- SetAssayData( # place into obj
#   iss_obj_invasive, 
#   layer = "data", 
#   new.data = log_transformed_counts
# )

# 2. Alternative Normalise with CPM scale
raw_counts <- GetAssayData(iss_obj_invasive, assay = "RNA", layer = "counts")
lib_size <- colSums(raw_counts)
cpm_counts <- t(t(raw_counts) / lib_size) * 1e6
log_cpm_counts <- log1p(cpm_counts)
iss_obj_invasive <- SetAssayData(
  object = iss_obj_invasive, 
  layer = "data", 
  new.data = log_cpm_counts
)

# 3. Feature selection & dim. reduction
iss_obj_invasive <- iss_obj_invasive %>%
  FindVariableFeatures(verbose = F) %>%
  ScaleData(do.scale = F, do.center = T) %>% # ensure do.scale is set to false!
  RunPCA(verbose = F) %>%
  FindNeighbors(dims = 1:10, verbose = F) %>%
  FindClusters(resolution = 0.6, algorithm = 4, verbose = F) %>% # 0.6
  RunUMAP(dims = 1:10, verbose = F)

# 4. Visualise Clusters
p6 <- DimPlot(iss_obj_invasive, label = F) +
  scale_color_viridis_d(option = "turbo") +
  ggtitle("Leiden Clustering"); p6

# 5. Map Clusters back to Metadata
cluster_map <- Idents(iss_obj_invasive)
iss_meta$cluster <- as.character(cluster_map[match(iss_meta$cell_id, names(cluster_map))])

ggsave(file.path(fig_subdir, "p6_leiden_cluster_tumour_cells.png"), plot = p6, dpi = 300)
```

#### Clustering Method Plots
```{r, fig.width=7.87*1.75, fig.height = 6.5*1.75, dpi=300, dev='tiff', out.width='100%'}
# Get turbo colour palette
clusters <- sort(unique(na.omit(iss_meta$cluster)))
n_clusters <- length(clusters)
turbo_cols <- viridis::viridis_pal(option = "turbo")(n_clusters)
names(turbo_cols) <- clusters

p7 <- ggplot(iss_meta, aes(x = y_centroid, y = x_centroid)) +
    # Layer 1: Plot "Other" (NA cluster) first as grey
    geom_point(data = subset(iss_meta, is.na(cluster)), 
               color = "white", 
               size = 0.01) +
    # Layer 2: Plot Clusters on top
    geom_point(data = subset(iss_meta, !is.na(cluster)), 
               aes(color = cluster), 
               size = 0.01) +
    # Use the Turbo palette (Discrete version)
    scale_color_viridis_d(option = "turbo") +
    # Swap xlim to ylim and apply reversal to the new y-axis
    coord_fixed(ylim = c(3850, 0)) +
    theme_minimal() +
    guides(color = guide_legend(override.aes = list(size = 2))); p7

ggsave(file.path(fig_subdir, "p7_ME_annotations_cluster_method.png"), plot = p7, dpi = 300)
```

```{r, fig.width=7.87*1.75, fig.height = 6.5*1.75, dpi=300, out.width='100%'}
# 1. Create a specific sub-directory for these individual plots
cluster_fig_dir <- file.path(fig_subdir, "individual_cluster_plots")
dir.create(cluster_fig_dir, showWarnings = FALSE)

# 2. Loop through each cluster to generate and save plots
# We use the 'clusters' and 'turbo_cols' defined in your previous chunk
for (current_cluster in clusters) {
  
  # Create the plot
  p_temp <- ggplot() +
    # Layer 1: Background - All OTHER Invasive cells (Grey)
    # Logic: Must have a cluster (be invasive), but NOT be the current cluster
    geom_point(data = subset(iss_meta, !is.na(cluster) & cluster != current_cluster), 
               aes(x = y_centroid, y = x_centroid), 
               color = "grey85", 
               size = 0.01) +
    
    # Layer 2: Foreground - The CURRENT Cluster (Specific Color)
    geom_point(data = subset(iss_meta, cluster == current_cluster), 
               aes(x = y_centroid, y = x_centroid), 
               color = "black", 
               size = 0.01) +
    
    # Formatting matching your previous styles
    coord_fixed(ylim = c(3850, 0)) +
    theme_minimal() +
    theme(legend.position = "none") + # Remove legend as title explains the plot
    ggtitle(paste("Invasive Tumor Cluster:", current_cluster))
  
  # Construct filename
  file_name <- paste0("cluster_", current_cluster, "_spatial_map.png")
  
  # Save the plot
  ggsave(filename = file.path(cluster_fig_dir, file_name), plot = p_temp, width = 7.87*1.25, height = 6.5*1.25, dpi = 300)
}
```

```{r}
# Bar plot of abundance of cells in each cluster superimposed with proportion of those found in iss_obj_invasive$surface_class_radius
cell_counts <- table(iss_meta$surface_class_radius, iss_meta$cluster)
cell_counts <- cell_counts[rownames(cell_counts) != "Other", ]

cell_counts_sorted <- cell_counts[, order(cell_counts["Core", ] / colSums(cell_counts), decreasing = TRUE)]

cols <- c("#fac0da", "#C90065")

barplot(height = cell_counts, col = cols, legend.text = T)
```


```{r}
# 5. classify based on clusters (manual hard-code annotation)
iss_meta <- iss_meta %>%
  mutate(surface_class_clusters = case_when(
    cluster %in% c("1", "2", "3", "5", "6") ~ "Core",
    cluster %in% c("4", "7") ~ "Surface",
    TRUE ~ "Other"
  ))

# Add new cluster metadata
iss_obj_invasive$surface_class_clusters <- iss_meta$surface_class_clusters[match(Cells(iss_obj_invasive), iss_meta$cell_id)]
```

```{r, fig.width=7.87*1.75, fig.height = 6.5*1.75, dpi=300, dev='tiff', out.width='100%'}
p8 <- ggplot(iss_meta, aes(x = y_centroid, y = x_centroid, color = surface_class_clusters)) +
    # Layer 1: Plot only "Other" first
    geom_point(data = subset(iss_meta, surface_class_clusters == "Other"),
               size = 0.01) +
    # Layer 2: Plot everything else on top
    geom_point(data = subset(iss_meta, surface_class_clusters != "Other"),
               size = 0.01) +
    scale_color_manual(values = c("Surface" = "#C90065", "Core" = "#fac0da", "Other" = "white")) +
    # Swap xlim to ylim and apply reversal to the new y-axis
    coord_fixed(ylim = c(3850, 0)) +
    theme_minimal() +
    guides(color = guide_legend(override.aes = list(size = 2)))

p8

ggsave(file.path(fig_subdir, "p7_ME_annotations_cluster_method_labelled.png"),
       plot = p8, dpi = 300, width = 7.87*1.75, height = 6.5*1.75)
```

# 6. Save Data
```{r}
# Save RDS
saveRDS(iss_obj_invasive, file ="/Users/glero527/Documents/microenvironments/01_data/janesick_2023/processed/iss_obj_invasive.RDS")
saveRDS(iss_meta, file = "/Users/glero527/Documents/microenvironments/01_data/janesick_2023/processed/iss_meta.RDS")
```

# Quick DGE analysis
```{r}
# 1. Set the active identity to the radius-method annotation
Idents(iss_obj_invasive) <- "surface_class_clusters"

# 2. Run DGE (Surface vs Core)
# ident.1 is the group of interest (Surface), ident.2 is the reference (Core)
markers <- FindMarkers(iss_obj_invasive, 
                       ident.1 = "Surface", 
                       ident.2 = "Core",
                       min.pct = 0.1,         # Only test genes detected in >10% of cells
                       logfc.threshold = 0.25 # Only test genes with >0.25 logFC
)

# 3. Filter for significant results (adjusted p-value < 0.05)
sig_markers <- subset(markers, p_val_adj < 0.05)
```

```{r}
# Plot DGE's
EnhancedVolcano(markers,
    lab = rownames(markers),
    x = 'avg_log2FC',
    y = 'p_val_adj',
    title = 'Surface vs Core',
    subtitle = 'Differential Expression',
    pCutoff = 0.05,
    FCcutoff = 0.5,
    pointSize = 2.0,
    labSize = 5.0,
    colAlpha = 0.8,
    legendPosition = 'right',
    legendLabSize = 10,
    legendIconSize = 3.0
)
```

# Subsample ISS counts to n counts
```{r}
# calculate sum nCount of core cells
core <- subset(iss_obj_invasive, subset = surface_class_radius == "Core")
surface <- subset(iss_obj_invasive, subset = surface_class_radius == "Surface")
mean(core$nCount_RNA)
mean(surface$nCount_RNA)
```
