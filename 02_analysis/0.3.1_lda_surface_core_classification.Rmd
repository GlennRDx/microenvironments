---
output:
  pdf_document:
    latex_engine: xelatex
geometry: margin=0.2in
---

```{r setup, include=FALSE, message = FALSE, warning = FALSE}
# Load config.R
source("config.R") 

# Set root directory using the variable from config
knitr::opts_knit$set(root.dir = data_dir)

# Load libraries
library(MASS)
library(dplyr)
library(data.table, quietly = T)
library(ggplot2)
library(caret)
```

```{r}
# Load Data
# iss_expr <- readRDS("janesick_2023/raw_clean/iss_expr_clean.RDS")
iss_obj_invasive <- readRDS("janesick_2023/processed/iss_obj_invasive.RDS")
shared_genes <- readRDS("janesick_2023/processed/shared_genes.RDS")
```

# Select 2/3 of the shared genes for training
```{r}
# Randomly select 2/3 of the shared genes for training
set.seed(lda_params$seed)
train_genes <- sample(shared_genes, size = floor(length(shared_genes) * lda_params$train_prop))

# Save list of training genes
saveRDS(train_genes, file = "janesick_2023/processed/train_genes.RDS")
```

# Filter confounding cells
- Cells labelled shallow core
- Cells labelled dead/dying cells (NAs in surface_classification_clusters)
```{r}
#calc number of cells before filt.
n_before <- ncol(iss_obj_invasive)

# filter out cells
# iss_obj_invasive <- subset(iss_obj_invasive, subset = depth_category != "Shallow Core")

iss_obj_invasive <- subset(iss_obj_invasive, subset = !is.na(surface_class_clusters))

n_after <- ncol(iss_obj_invasive)

cat(round((n_before - n_after)/n_before, 2)*100, "% cells removed.")
```

# Normalise the matrix
```{r}
iss_obj_invasive <- NormalizeData(iss_obj_invasive)
```

# Extract normalised counts, add surface_class column
```{r}
inv_tumour_expr <- as.data.frame(t(as.matrix(LayerData(iss_obj_invasive, layer = "data"))))

inv_tumour_expr$surface_class <- iss_obj_invasive@meta.data[, classification_method]
rownames(inv_tumour_expr) <- iss_obj_invasive@meta.data[, 'cell_id']
```


# Split full dataset into training / test datasets (80/20 split)
```{r}
# Take 80% for training dataset
inv_gene_exp_train <- inv_tumour_expr %>%
  mutate(cell_id = rownames(.)) %>%
  group_by(surface_class) %>%
  slice_sample(prop = lda_params$split_prop) %>%
  ungroup()

# Use remaining 20% for test dataset
inv_gene_exp_test <- inv_tumour_expr %>%
  mutate(cell_id = rownames(.)) %>%
  filter(!cell_id %in% inv_gene_exp_train$cell_id)

# Restore the cell_id's to the rownames and remove the cell_id column
inv_gene_exp_train <- as.data.frame(inv_gene_exp_train) # convert to df to allow assignment of rownames
rownames(inv_gene_exp_train) <- inv_gene_exp_train$cell_id
inv_gene_exp_train$cell_id <- NULL

inv_gene_exp_test <- as.data.frame(inv_gene_exp_test) # convert to df to allow assignment of rownames
rownames(inv_gene_exp_test) <- inv_gene_exp_test$cell_id
inv_gene_exp_test$cell_id <- NULL
```

# Feature selection  
 - Remove genes that have zero variance and thus are not discriminatory between groups.  
```{r}
gene_cols <- setdiff(colnames(inv_gene_exp_train), "surface_class")

# Calculate variance within each group for each gene
keep_genes <- sapply(gene_cols, function(gene) {
  var_by_group <- inv_gene_exp_train %>%
    group_by(surface_class) %>%
    summarise(var = var(.data[[gene]], na.rm = TRUE), .groups = 'drop')

  # Keep gene if it has non-zero variance in at least one group
  any(var_by_group$var > 0)
})

# Filter to keep only informative genes
genes_to_keep <- names(keep_genes)[keep_genes]
genes_removed <- names(keep_genes)[!keep_genes]

print("Genes removed:")
print(genes_removed)

inv_gene_exp_filtered <- inv_gene_exp_train %>%
  dplyr::select(surface_class, all_of(genes_to_keep))

saveRDS(genes_to_keep, file = "janesick_2023/processed/genes_to_keep.RDS")
```

# Remove NAs
```{r}
# Remove rows with NA in surface_class before fitting
inv_gene_exp_filtered <- inv_gene_exp_filtered %>%
  filter(!is.na(surface_class))
```


# Fit LDA model
```{r}
fit_lda <- lda(surface_class ~ ., inv_gene_exp_filtered)

saveRDS(fit_lda, file = "janesick_2023/processed/fit_lda.RDS")
```

# Plot first two linear discriminants
```{r, fig.width=7.87, dpi=300, dev='tiff', out.width='100%'}
# Define figure directory based on your request
fig_subdir <- file.path(figs_dir, "0.3.1")
if(!dir.exists(fig_subdir)) dir.create(fig_subdir, recursive = TRUE)

# Calculate LDA values
lda_values <- predict(fit_lda)$x
lda_df <- data.frame(LD1 = lda_values[,1], surface_class = inv_gene_exp_filtered$surface_class)

# Define readable labels for the config settings
method_labels <- c(
  "surface_class_radius"   = "Radius Definition",
  "surface_class_nn"       = "KNN Definition",
  "surface_class_clusters" = "Unsupervised Clustering"
)

# Get the nice label for the current run
current_label <- method_labels[classification_method]
if(is.na(current_label)) current_label <- classification_method

# Create the plot
p_lda <- ggplot(lda_df, aes(x = LD1, fill = surface_class)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(
    title = "LDA Projection of Surface vs Core Cells", 
    subtitle = paste0("Ground Truth Annotation: ", current_label),
    x = "LD1", 
    y = "Density",
    fill = "Region"
  ) +
  theme(
    plot.title = element_text(face = "bold", size = 12),
    plot.subtitle = element_text(size = 10, color = "gray30")
  )

# Print the plot to the Rmarkdown output
print(p_lda)

# Save the plot to the specific folder
ggsave(
  filename = file.path(fig_subdir, paste0("LDA_density_", classification_method, ".png")),
  plot = p_lda,
  dpi = 300,
  width = 8,
  height = 6
)
```

# Predict surface_class with LDA model
```{r}
# Subset test data to only include genes used in the LDA model
inv_gene_exp_test_filtered <- inv_gene_exp_test %>%
  dplyr::select(surface_class, all_of(genes_to_keep))

# Predict surface_class for test data
lda_predictions <- predict(fit_lda, newdata = inv_gene_exp_test_filtered)
```

```{r}
inv_gene_exp_test$predicted_surface_class <- lda_predictions$class
predicted_classes <- lda_predictions$class
```

```{r}
accuracy <- mean(predicted_classes == inv_gene_exp_test$surface_class)
print(paste("Test Accuracy:", round(accuracy, 3)))
```

```{r}
# --- Predict surface_class with LDA model ---

# Subset test data to only include genes used in the LDA model
inv_gene_exp_test_filtered <- inv_gene_exp_test %>%
  dplyr::select(surface_class, all_of(genes_to_keep))

# Predict surface_class for test data
lda_predictions <- predict(fit_lda, newdata = inv_gene_exp_test_filtered)

# Add predictions to dataframe
inv_gene_exp_test$predicted_surface_class <- lda_predictions$class
predicted_classes <- lda_predictions$class

# Calculate Accuracy
accuracy <- mean(predicted_classes == inv_gene_exp_test$surface_class)
print(paste("Test Accuracy:", round(accuracy, 3)))

# --- Generate and Save Confusion Matrix ---

# Create confusion matrix object
conf_matrix <- confusionMatrix(
  factor(predicted_classes),
  factor(inv_gene_exp_test$surface_class)
)

# Print to Rmarkdown
print(conf_matrix)

# Save the full confusion matrix output to a text file
capture.output(
  conf_matrix, 
  file = file.path(fig_subdir, paste0("confusion_matrix_", classification_method, ".txt"))
)
```