---
output:
  pdf_document:
    latex_engine: xelatex
geometry: margin=0.2in
---

# 1. Load files & Libraries
```{r setup, include=FALSE, message = FALSE, warning = FALSE}
# Load config.R
source("config.R") 

# Set root directory using the variable from config
knitr::opts_knit$set(root.dir = data_dir)

# Define figure directory based on your request
fig_subdir <- file.path(figs_dir, "0.3.1")
if(!dir.exists(fig_subdir)) dir.create(fig_subdir, recursive = TRUE)

# Load libraries
library(MASS)
library(dplyr)
library(data.table, quietly = T)
library(ggplot2)
library(caret)
```
```{r}
# Load Data
# iss_expr <- readRDS("janesick_2023/raw_clean/iss_expr_clean.RDS")
iss_obj_invasive <- readRDS("janesick_2023/processed/iss_obj_invasive.RDS")
shared_genes <- readRDS("janesick_2023/processed/shared_genes.RDS")
```

# 2. Select 2/3 of the shared genes (between ISS/scRNA) for training
```{r}
# Randomly select 2/3 of the shared genes for training
set.seed(lda_params$seed)
train_genes <- sample(shared_genes, size = floor(length(shared_genes) * lda_params$train_prop))

# Save list of training genes
saveRDS(train_genes, file = "janesick_2023/processed/train_genes.RDS")
```

# 3. Filter confounding cells (comment out until we properly define the confounding cells)
- Cells labelled shallow core
- Cells labelled dead/dying cells (NAs in surface_classification_clusters)
```{r}
# #calc number of cells before filt.
# n_before <- ncol(iss_obj_invasive)
# 
# # filter out cells
# # iss_obj_invasive <- subset(iss_obj_invasive, subset = depth_category != "Shallow Core")
# 
# iss_obj_invasive <- subset(iss_obj_invasive, subset = !is.na(surface_class_clusters))
# 
# n_after <- ncol(iss_obj_invasive)
# 
# cat(round((n_before - n_after)/n_before, 2)*100, "% cells removed.")
```

# 4. Normalise the matrix with log transformation (commented out bc already did in 0.2.1)
```{r}
# # Manual Log Transformation
# # 1. Pull the raw counts
# raw_counts <- GetAssayData(iss_obj_invasive, assay = "RNA", layer = "counts")
# 
# # 2. log transformation without scaling/centering
# log_transformed_counts <- log1p(raw_counts)
# 
# # 3. Place into 'data' layer for downstream extraction
# iss_obj_invasive <- SetAssayData(
#   iss_obj_invasive, 
#   layer = "data", 
#   new.data = log_transformed_counts
# )
```

# 5. Extract normalised expr matrix, add surface_class column
```{r}
# 1. Extract expression
expr_mat <- t(as.matrix(LayerData(iss_obj_invasive, layer = "data")))
inv_tumour_expr <- as.data.frame(expr_mat)

# 2. Extract metadata with row names explicitly
meta_data <- iss_obj_invasive@meta.data[, c(classification_method, "cell_id"), drop = FALSE]
colnames(meta_data)[1] <- "surface_class" # Rename dynamic column

# 3. Merge safely
inv_tumour_expr <- merge(inv_tumour_expr, meta_data, by = "row.names")
rownames(inv_tumour_expr) <- inv_tumour_expr$Row.names
inv_tumour_expr$Row.names <- NULL

# 4. Filter
inv_tumour_expr <- inv_tumour_expr %>%
  filter(surface_class %in% c("Surface", "Core"))
```

# 6. Split full dataset into training / test datasets (80/20 split)
```{r}
# Take 80% for training dataset
inv_gene_exp_train <- inv_tumour_expr %>%
  mutate(cell_id = rownames(.)) %>%
  group_by(surface_class) %>%
  slice_sample(prop = lda_params$split_prop) %>%
  ungroup()

# Use remaining 20% for test dataset
inv_gene_exp_test <- inv_tumour_expr %>%
  mutate(cell_id = rownames(.)) %>%
  filter(!cell_id %in% inv_gene_exp_train$cell_id)

# Restore the cell_id's to the rownames and remove the cell_id column
inv_gene_exp_train <- as.data.frame(inv_gene_exp_train) # convert to df to allow assignment of rownames
rownames(inv_gene_exp_train) <- inv_gene_exp_train$cell_id
inv_gene_exp_train$cell_id <- NULL

inv_gene_exp_test <- as.data.frame(inv_gene_exp_test) # convert to df to allow assignment of rownames
rownames(inv_gene_exp_test) <- inv_gene_exp_test$cell_id
inv_gene_exp_test$cell_id <- NULL
```

```{r}
# 80
table(inv_gene_exp_filtered$surface_class)

table(inv_gene_exp_test$surface_class)
```
# 7. Filter genes to include only the training genes
```{r}
inv_gene_exp_train <- inv_gene_exp_train %>%
  dplyr::select(surface_class, all_of(train_genes))
```

# 8. Feature selection  (commented out as 111 genes were being removed due to low variance)
 - Remove genes that have near zero variance and thus are not discriminatory between groups.  
```{r}
# nzv_cols <- nearZeroVar(inv_gene_exp_train[, train_genes], saveMetrics = FALSE)
# 
# if(length(nzv_cols) > 0){
#   genes_to_drop <- train_genes[nzv_cols]
#   genes_to_keep <- setdiff(train_genes, genes_to_drop)
# } else {
#   genes_to_keep <- train_genes
# }
# 
# print(paste(length(train_genes) - length(genes_to_keep), "genes removed due to low variance."))
# 
# # Filter training set
# inv_gene_exp_filtered <- inv_gene_exp_train %>%
#   dplyr::select(surface_class, all_of(genes_to_keep)) %>%
#   filter(!is.na(surface_class)) # Ensure no NAs in target
# 
# saveRDS(genes_to_keep, file = "janesick_2023/processed/genes_to_keep.RDS")

# renamed variables to make the next code blocks work as the above code is commented out
genes_to_keep <- train_genes
inv_gene_exp_filtered <- inv_gene_exp_train
saveRDS(genes_to_keep, file = "janesick_2023/processed/genes_to_keep.RDS")
```

# 9. Fit LDA model
```{r}
# Split into X (features) and Y (labels) for efficient processing
x_train <- inv_gene_exp_filtered %>% dplyr::select(-surface_class)
y_train <- inv_gene_exp_filtered$surface_class

# Fit LDA using x/grouping syntax (faster than formula ~ .)
fit_lda <- lda(x = x_train, grouping = y_train)

saveRDS(fit_lda, file = "janesick_2023/processed/fit_lda.RDS")
```

# 10. Plot LDA
```{r, fig.width=7.87, dpi=300, dev='tiff', out.width='100%'}
# Calculate LDA values
lda_values <- predict(fit_lda)$x
lda_df <- data.frame(LD1 = lda_values[,1], surface_class = inv_gene_exp_filtered$surface_class)

# Define labels & set current label
method_labels <- c(
  "surface_class_radius"   = "Radius Definition",
  "surface_class_nn"       = "KNN Definition",
  "surface_class_clusters" = "Unsupervised Clustering"
)
current_label <- method_labels[classification_method]
if(is.na(current_label)) current_label <- classification_method

# Plot
p_lda <- ggplot(lda_df, aes(x = LD1, fill = surface_class)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(
    title = "LDA Projection of Surface vs Core Cells", 
    subtitle = paste0("Ground Truth Annotation: ", current_label),
    x = "LD1", 
    y = "Density",
    fill = "Region"
  ) +
  theme(
    plot.title = element_text(face = "bold", size = 12),
    plot.subtitle = element_text(size = 10, color = "gray30")
  ); p_lda

# Save plot
ggsave(filename = file.path(fig_subdir, paste0("LDA_density_", classification_method, ".png")), plot = p_lda, dpi = 300)
```

# 11. Predict test set surface_class using the fitted LDA model
```{r}
# 1. Subset test data to match model features
inv_gene_exp_test_filtered <- inv_gene_exp_test %>%
  dplyr::select(all_of(genes_to_keep))

# 2. Predict
lda_predictions <- predict(fit_lda, newdata = inv_gene_exp_test_filtered)

# 3. Add predictions to test dataframe
inv_gene_exp_test$predicted_surface_class <- lda_predictions$class
predicted_classes <- lda_predictions$class

# 4. Calculate Accuracy
accuracy <- mean(predicted_classes == inv_gene_exp_test$surface_class)
print(paste("Test Accuracy:", round(accuracy, 3)))

# 5. Generate and Save Confusion Matrix
conf_matrix <- confusionMatrix(
  factor(predicted_classes),
  factor(inv_gene_exp_test$surface_class)
);  conf_matrix

# Save the matrix text
capture.output(
  conf_matrix, 
  file = file.path(fig_subdir, paste0("confusion_matrix_", classification_method, ".txt"))
)
```

# Plot test results
```{r, fig.width=7.87*1.75, fig.height = 6.5*1.75, dpi=300, dev='tiff', out.width='100%'}
# 1. Prepare Plotting Data
# Extract full metadata from the Seurat object
plot_meta <- iss_obj_invasive@meta.data

# Create a column for Classification Status
plot_meta$classification_status <- "Training"

# Identify Test Set cells
test_cells <- rownames(inv_gene_exp_test)

plot_meta[test_cells, "classification_status"] <- ifelse(
  inv_gene_exp_test$surface_class == inv_gene_exp_test$predicted_surface_class,
  "Test Correct",
  paste0("False ", inv_gene_exp_test$predicted_surface_class)
)

# 2. Setup Colors
colors <- c("Training" = "grey90", "Test Correct" = "green", "False Surface" = "red", "False Core" = "blue")

# 3. Plot
ggplot(plot_meta, aes(x = y_centroid, y = x_centroid, color = classification_status)) +
    # Layer 1: Training
    geom_point(data = subset(plot_meta, classification_status == "Training"), 
               size = 0.01) +
    # Layer 2: Correct Predictions
    geom_point(data = subset(plot_meta, classification_status == "Test Correct"), 
               size = 0.01) +
    # Layer 3: False Surface
    geom_point(data = subset(plot_meta, classification_status == "False Surface"), 
               size = 0.01) +
    # Layer 4: False Core
    geom_point(data = subset(plot_meta, classification_status == "False Core"), 
               size = 0.01) +
    scale_color_manual(values = colors) +
    # Swap xlim to ylim and apply reversal to the new y-axis
    coord_fixed(ylim = c(3850, 0)) +
    theme_minimal() +
    guides(color = guide_legend(override.aes = list(size = 3)))
```

# Write code to train LDA model using all data.
```{r}

```

