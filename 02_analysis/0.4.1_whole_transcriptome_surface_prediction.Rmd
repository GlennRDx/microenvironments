---
output:
  pdf_document:
    latex_engine: xelatex
geometry: margin=0.2in
---

# 1. Load files & Libraries
```{r setup, include=FALSE, message = FALSE, warning = FALSE}
# Load config.R
source("config.R") 

# Set root directory using the variable from config
knitr::opts_knit$set(root.dir = data_dir)

# Define Figure Directory 
fig_subdir <- file.path(figs_dir, "0.4.1")
if(!dir.exists(fig_subdir)) dir.create(fig_subdir, recursive = TRUE)

# Load libraries
library(MASS)
library(dplyr)
library(data.table)
library(Seurat)
library(ggplot2)
library(tidyverse)
```
```{r}
# load files
fit_lda <- readRDS("janesick_2023/processed/fit_lda.RDS")
shared_genes <- readRDS("janesick_2023/processed/shared_genes.RDS")
genes_to_keep <- readRDS("janesick_2023/processed/genes_to_keep.RDS")
wts_obj <- readRDS("janesick_2023/processed/wts_obj_processed.RDS")
wts_expr_clean <- fread("janesick_2023/raw/scRNAseq_data_quantile_matched.txt") %>% as.data.frame()
```

# 2. Replace counts with quantile matched counts
```{r}
# 1. clean up quant. matched data
rownames(wts_expr_clean) <- wts_expr_clean$V1
wts_expr_clean$V1 <- NULL

# 2. Remove genes which are not shared between ISS and WTS
wts_obj <- subset(wts_obj, features = shared_genes)

# 3. Reorder/subset the new matrix to match the Seurat object's cells/genes
wts_expr_clean <- wts_expr_clean[rownames(wts_obj), colnames(wts_obj)]

# 4. covert quantile matched counts to sparse matrix
counts_matrix_sparse <- as(as.matrix(wts_expr_clean), "dgCMatrix")

# 5. Replace old RAW counts with quantile matched sparse matrix
wts_obj[["RNA"]] <- SetAssayData(object = wts_obj[["RNA"]], 
                             layer = "counts", 
                             new.data = counts_matrix_sparse)

# 6. Filter to invasive tumour cells only
wts_obj_invasive <- subset(wts_obj, subset = Annotation %in% "Invasive_Tumor")
```

# 3. Normalise (log + CPM)
```{r}
# 1. Extract raw counts
raw_counts <- GetAssayData(wts_obj_invasive, assay = "RNA", layer = "counts")

# 2. Calculate library size (total counts per cell)
lib_size <- colSums(raw_counts)

# 3. Normalise to CPM (Counts Per Million)
cpm_counts <- t(t(raw_counts) / lib_size) * 1e6

# 4. Log transform: log(CPM + 1)
log_cpm_counts <- log1p(cpm_counts)

# 5. Place back into the 'data' layer
wts_obj_invasive <- SetAssayData(
  object = wts_obj_invasive, 
  layer = "data", 
  new.data = log_cpm_counts
)
```

# Extract normalised count matrix in preparation for prediction
```{r}
inv_tumour_expr <- as.data.frame(t(as.matrix(LayerData(wts_obj_invasive, layer = "data"))))
```

# 4. Align genes between two data sets
```{r}
# 1. Align columns (genes) to match the LDA model order exactly
expr_df_aligned <- inv_tumour_expr[, genes_to_keep]

# 2. Verify check
if(ncol(expr_df_aligned) != length(genes_to_keep)) {
  stop("Error: Column count mismatch. Verify that all training genes are present in scRNA-seq data.")
}
```

# 5. Apply LDA model to predict surface / core labels
```{r}
# Make predictions
lda_predictions <- predict(fit_lda, newdata = expr_df_aligned)

# Extract predicted classes and posterior probabilities
predicted_classes <- lda_predictions$class
posterior_probs <- lda_predictions$posterior
lda_scores <- lda_predictions$x

# Create results dataframe
results_df <- data.frame(
  cell_id = rownames(expr_df_aligned),
  predicted_class = predicted_classes,
  prob_core = posterior_probs[, "Core"],
  prob_surface = posterior_probs[, "Surface"],
  LD1 = lda_scores[, 1],
  annotation = wts_obj_invasive$Annotation[match(rownames(expr_df_aligned), colnames(wts_obj_invasive))],
  stringsAsFactors = FALSE
)

# results_df_filtered <- results_df %>%
  # filter(LD1 < -0.5 | LD1 > -0.2)

# identify the ma probability for each cell and then filter if less than the prob_threshold
results_df <- results_df %>%
  mutate(max_prob = pmax(prob_core, prob_surface),
         status = ifelse(max_prob >= prediction_params$prob_threshold, "High Confidence", "Ambiguous"))

results_df_filtered <- results_df %>%
  filter(status == "High Confidence")

# Summary of predictions (UPDATE THIS)
cat("\n=== Prediction Summary ===\n")
cat("Total cells predicted:", nrow(results_df), "\n")
cat("High-confidence cells:", nrow(results_df_filtered), "\n")
cat("Filtered out (ambiguous):", nrow(results_df) - nrow(results_df_filtered), "\n\n")
cat("High-confidence class distribution:\n")
print(table(results_df_filtered$predicted_class))
```
# 6. Plot LDA
```{r}
# 1. Prepare Stats for Plot Labels 
# Count stats from the full results_df
n_high_conf_core <- sum(results_df$predicted_class == "Core" & results_df$status == "High Confidence")
n_high_conf_surf <- sum(results_df$predicted_class == "Surface" & results_df$status == "High Confidence")
n_ambiguous <- sum(results_df$status == "Ambiguous")



# 2. Plot Labels
stats_label <- paste0(
  "High Conf. Core: ", n_high_conf_core, "\n",
  "High Conf. Surface: ", n_high_conf_surf, "\n",
  "Ambiguous: ", n_ambiguous
)
method_labels <- c(
  "surface_class_radius"   = "Radius Definition",
  "surface_class_nn"       = "KNN Definition",
  "surface_class_clusters" = "Unsupervised Clustering"
)
current_label <- method_labels[classification_method]
if(is.na(current_label)) current_label <- classification_method



# 3. Plot 
p_pred <- ggplot(results_df, aes(x = LD1, fill = predicted_class)) +
  geom_density(alpha = 0.5) +
  
  # Add the stats box
  annotate("label", x = Inf, y = Inf, label = stats_label, 
           hjust = 1.1, vjust = 1.1, size = 3.5, 
           fill = "white", alpha = 0.8, color = "black") +
  
  theme_minimal() +
  labs(
    title = "LDA Projection of scRNA-seq Predictions", 
    subtitle = paste0("Model Trained on: ", current_label),
    x = "LD1", 
    y = "Density",
    fill = "Predicted Class"
  ) +
  theme(
    plot.title = element_text(face = "bold", size = 12),
    plot.subtitle = element_text(size = 10, color = "gray30")
  ); p_pred


# 4. Save
ggsave(filename = file.path(fig_subdir, paste0("scRNA_LDA_projection_", classification_method, ".png")), plot = p_pred, dpi = 300)
```

# 7. Add Predictions to Seurat Object
```{r}
# Create a dataframe for the new metadata, ensuring row names are cell IDs
meta_to_add <- results_df_filtered %>%
  tibble::remove_rownames() %>%
  dplyr::select(cell_id, predicted_surface_class = predicted_class, prob_core, LD1_score = LD1) %>%
  tibble::column_to_rownames("cell_id")

# Add to invasive object
wts_obj_invasive <- AddMetaData(wts_obj_invasive, metadata = meta_to_add)

# Add to full object (cells not in the list will automatically get NAs)
wts_obj <- AddMetaData(wts_obj, metadata = meta_to_add)

# Quick check
print(table(wts_obj$predicted_surface_class, useNA = "ifany"))
```

# 8. Save
```{r}
saveRDS(wts_obj_invasive, file = "janesick_2023/processed/wts_obj_invasive.RDS")
```