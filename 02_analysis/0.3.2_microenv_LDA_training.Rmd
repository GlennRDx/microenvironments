---
output:
  pdf_document:
    latex_engine: xelatex
geometry: margin=0.2in
---

# 1. Load files & Libraries
```{r setup, include=FALSE, message = FALSE, warning = FALSE}
# Load config.R
source("config.R") 

# Set root directory using the variable from config
knitr::opts_knit$set(root.dir = data_dir)

# Define figure directory based on your request
fig_subdir <- file.path(figs_dir, "0.3.1")
if(!dir.exists(fig_subdir)) dir.create(fig_subdir, recursive = TRUE)

# Load libraries
library(MASS)
library(dplyr)
library(data.table, quietly = T)
library(ggplot2)
library(caret)
library(Seurat)
```

```{r}
# Load Data
iss_obj_invasive <- readRDS("janesick_2023/processed/iss_obj_invasive.RDS")
shared_genes <- readRDS("janesick_2023/processed/shared_genes.RDS")
```

# 2. Select 2/3 genes
```{r}
# Randomly select 2/3 of the shared genes for training
set.seed(lda_params$seed)
train_genes <- sample(shared_genes, size = floor(length(shared_genes) * lda_params$train_prop))

# Save list of training genes
saveRDS(train_genes, file = "janesick_2023/processed/train_genes.RDS")
```

# 3. Filter confounding cells
```{r}
# iss_obj_invasive <- subset(iss_obj_invasive, subset = seurat_clusters != 8)
```

# 4. Normalise matrix
```{r}
# Manual Log Transformation
raw_counts <- GetAssayData(iss_obj_invasive, assay = "RNA", layer = "counts")
cpm <-t(t(raw_counts) / colSums(raw_counts)) * 1e6
log_transformed_counts <- log1p(cpm)

iss_obj_invasive <- SetAssayData(iss_obj_invasive, layer = "data", new.data = log_transformed_counts)
```

# 5. Extract normalised expr matrix and prep
```{r}
# 1. Extract expression
expr_mat <- t(as.matrix(LayerData(iss_obj_invasive, layer = "data")))
inv_tumour_expr <- as.data.frame(expr_mat)

# 2. Extract metadata
meta_data <- iss_obj_invasive@meta.data[, c(classification_method, "cell_id"), drop = FALSE]
colnames(meta_data)[1] <- "surface_class" 

# 3. Merge safely
inv_tumour_expr <- merge(inv_tumour_expr, meta_data, by = "row.names")
rownames(inv_tumour_expr) <- inv_tumour_expr$Row.names
inv_tumour_expr$Row.names <- NULL

# 4. Filter for only Surface/Core
inv_tumour_expr <- inv_tumour_expr %>%
  filter(surface_class %in% c("Surface", "Core"))
```

# 6. 5-fold CV
```{r}
# 1. Create 5 stratified folds
set.seed(lda_params$seed)
folds <- createFolds(inv_tumour_expr$surface_class, k = 5, list = TRUE, returnTrain = FALSE)

# 2. Initialize column for predictions
inv_tumour_expr$cv_predicted_class <- NA

# 3. Loop through folds
for(i in 1:5) {
  # Indices for current test set
  test_idx <- folds[[i]]
  
  # Split data
  train_data <- inv_tumour_expr[-test_idx, ]
  test_data  <- inv_tumour_expr[test_idx, ]
  
  # Select specific features (genes)
  train_data_filt <- train_data %>% dplyr::select(surface_class, all_of(shared_genes))
  test_data_filt  <- test_data  %>% dplyr::select(all_of(shared_genes))
  
  # Fit LDA on Training portion
  fit_cv <- lda(x = train_data_filt %>% dplyr::select(-surface_class), 
                grouping = train_data_filt$surface_class)
  
  # Predict on Test portion
  preds <- predict(fit_cv, newdata = test_data_filt)$class
  
  # Store predictions
  inv_tumour_expr$cv_predicted_class[test_idx] <- as.character(preds)
}
```

# 7. Evaluate
```{r}
# 1. Calculate Overall Accuracy
accuracy <- mean(inv_tumour_expr$surface_class == inv_tumour_expr$cv_predicted_class)
print(paste("5-Fold CV Accuracy:", round(accuracy, 3)))

# 2. Generate Confusion Matrix
conf_matrix <- confusionMatrix(
  factor(inv_tumour_expr$cv_predicted_class),
  factor(inv_tumour_expr$surface_class)
); conf_matrix

# Save the matrix text
capture.output(
  conf_matrix, 
  file = file.path(fig_subdir, paste0("confusion_matrix_CV_", classification_method, ".txt"))
)
```

# 8. Plot
```{r, fig.width=7.87*1.75, fig.height = 6.5*1.75, dpi=300, dev='tiff', out.width='100%'}
# 1. Prepare Plotting Data
plot_meta <- iss_obj_invasive@meta.data
plot_meta$classification_status <- NA # Initialize

# Map CV predictions to the metadata
# We only map cells present in our filtered dataset
common_cells <- intersect(rownames(plot_meta), rownames(inv_tumour_expr))
cv_subset <- inv_tumour_expr[common_cells, ]

plot_meta[common_cells, "classification_status"] <- ifelse(
  cv_subset$surface_class == cv_subset$cv_predicted_class,
  "Correct",
  paste0("False ", cv_subset$cv_predicted_class)
)

# 2. Setup Colors
# Grey for correct, Red for False Surface (Core misclassified), Blue for False Core (Surface misclassified)
colors <- c("Correct" = "grey90", "False Surface" = "red", "False Core" = "blue")

# 3. Plot
p_spatial <- ggplot(plot_meta, aes(x = y_centroid, y = x_centroid, color = classification_status)) +
    # Layer 1: Correct (Background)
    geom_point(data = subset(plot_meta, classification_status == "Correct"), 
               size = 0.01) +
    # Layer 2: False Surface (Errors)
    geom_point(data = subset(plot_meta, classification_status == "False Surface"), 
               size = 0.01) +
    # Layer 3: False Core (Errors)
    geom_point(data = subset(plot_meta, classification_status == "False Core"), 
               size = 0.01) +
    scale_color_manual(values = colors, na.value = "transparent") +
    coord_fixed(ylim = c(3850, 0)) +
    theme_minimal() +
    labs(title = paste0("5-Fold CV Spatial Errors (Acc: ", round(accuracy, 2), ")")) +
    guides(color = guide_legend(override.aes = list(size = 3)))

p_spatial

# Save Plot
ggsave(filename = file.path(fig_subdir, paste0("CV_spatial_errors_", classification_method, ".png")), plot = p_spatial, dpi = 300)
```

# 9. Validation model (2/3 genes, 100% cells)
```{r}
validation_data <- inv_tumour_expr %>%
  dplyr::select(surface_class, all_of(train_genes))

# Fit Validation LDA
fit_lda_val <- lda(
  x = validation_data %>% dplyr::select(-surface_class), 
  grouping = validation_data$surface_class
)

# Save
saveRDS(fit_lda_val, file = "janesick_2023/processed/fit_lda_val.RDS")
```

# 9. Train final LDA model using all cells, all genes
```{r}
# Filter for training genes
final_data <- inv_tumour_expr %>%
  dplyr::select(surface_class, all_of(shared_genes))

# Fit Final LDA
fit_lda_final <- lda(
  x = final_data %>% dplyr::select(-surface_class), 
  grouping = final_data$surface_class
)

# Save
saveRDS(fit_lda_final, file = "janesick_2023/processed/fit_lda.RDS")
```
test