---
output:
  pdf_document:
    latex_engine: xelatex
geometry: margin=0.2in
---

# 1. Load files & Libraries
```{r setup, include=FALSE, message = FALSE, warning = FALSE}
# Load config.R
source("config.R") 

# Set root directory using the variable from config
knitr::opts_knit$set(root.dir = data_dir)

# Figures Folder
fig_subdir <- file.path(figs_dir, "0.2.1")
if(!dir.exists(fig_subdir)) dir.create(fig_subdir, recursive = TRUE)

# Load libraries
library(tidyverse, quietly = T) # CRAN
library(Matrix, quietly = T) # CRAN
library(ggplot2, quietly = T) # CRAN
library(data.table, quietly = T) # CRAN
library(Seurat, quietly = T) # CRAN
library(dplyr, quietly = T) # CRAN
library(viridis, quietly = T) # CRAN
library(sctransform, quietly = T) # CRAN
library(RANN, quietly = T) # CRAN
library(ggrastr, quietly = T) # CRAN
library(cowplot)
library(paletteer)
library(scry, quietly = T) # bioconductor
library(SingleCellExperiment, quietly = T) # bioconductor
```
```{r}
# Load data
iss_expr <- readRDS("janesick_2023/raw_clean/iss_expr_clean.RDS")
iss_meta <- readRDS("janesick_2023/raw_clean/iss_meta_clean.RDS")
setDT(iss_meta) # Set to data.table for speed
```

# 2. Radius Method
```{r}
start_time <- Sys.time()

# 1. Prep coordinates
coords <- iss_meta[, .(x_centroid, y_centroid)] #Q: what does the period do?

# 2. Perform radius search (returns the indices)
nn_result <- nn2(data = coords, query = coords, searchtype = "radius", radius = iss_params$radius, k = 200)

# 3. Identify target cell indices (invasice tumour cells)
invasive_idx <- which(iss_meta$Annotation == "Invasive_Tumor")
is_tumour_neighbour <- iss_meta$Annotation %in% c("Invasive_Tumor", "Prolif_Invasive_Tumor")

# 4. Calculate the fraction (vectorised for speed)
classification_vec <- vapply(invasive_idx, function(i) {
  
  nb_idx <- nn_result$nn.idx[i, ] # get the neighbour ids
  nb_idx <- nb_idx[nb_idx != 0 & nb_idx != i] # exclude self and 0 padding added by nn2
  if (length(nb_idx) == 0) return("Surface") # Edge case, if a cell has no neighbours in radius, it's a surface cell
  
  frac <- sum(is_tumour_neighbour[nb_idx]) / length(nb_idx) # Calculate Fraction
  
  if (frac > iss_params$threshold) "Core" else "Surface"
}, FUN.VALUE = character(1))

# 5. enrich metadata
iss_meta$surface_class_radius <- "Other" # Set everything to "Other"
iss_meta$surface_class_radius[invasive_idx] <- classification_vec # Overwrite "Other" with new Surface/Core classes

neighbour_counts <- rowSums(nn_result$nn.idx[invasive_idx, ] != 0) - 1
iss_meta$neighbour_count <- NA
iss_meta$neighbour_count[invasive_idx] <- neighbour_counts

end_time <- Sys.time()

cat("Classification took:", round(end_time - start_time, 2))

table(iss_meta$surface_class_radius)
```

#### Radius Method Plots
```{r, fig.width=7.87*1.75, fig.height = 6.5*1.75, dpi=300, dev='tiff', out.width='100%'}
mean_val <- mean(iss_meta$neighbour_count, na.rm = T)
p1 <- ggplot(subset(iss_meta, !is.na(neighbour_count)), aes(x = neighbour_count)) +
  geom_bar(fill = "#AA4A44", color = "black", width = 1, linewidth = 0) +
  
  # Add the vertical line for the mean
  geom_vline(aes(xintercept = mean_val), color = "black", linetype = "dashed", linewidth = 1) +
  
  theme_minimal() +
  labs(
    title = "Distribution of Counts of cells with n neighbours within radius",
    subtitle = paste("Radius =", iss_params$radius, "\nMean n =", round(mean_val, 2)),
    x = "Number of Neighbours in Radius",
    y = "Count of Cells"
  ); p1

ggsave(file.path(fig_subdir, "p1_dist_of_counts_of_cells_with_n_neighbours_in_radius.png"), plot = p1, dpi = 300)
p2 <- ggplot(iss_meta, aes(x = y_centroid, y = x_centroid, color = surface_class_radius)) +
    # Layer 1: Plot only "Other" first
    geom_point(data = subset(iss_meta, surface_class_radius == "Other"), 
               size = 0.01) +
    # Layer 2: Plot everything else on top
    geom_point(data = subset(iss_meta, surface_class_radius != "Other"), 
               size = 0.01) +
    scale_color_manual(values = c("Surface" = "#C90065", "Core" = "#fac0da", "Other" = "grey75")) +
    # Swap xlim to ylim and apply reversal to the new y-axis
    coord_fixed(ylim = c(3850, 0)) +
    theme_minimal() +
    guides(color = guide_legend(override.aes = list(size = 2))); p2

ggsave(file.path(fig_subdir, "p2_ME_annotations_radius_method.png"), plot = p2, dpi = 300)
```

# 3. KNN Method
```{r}
# 1. Get Indices
invasive_idx <- which(iss_meta$Annotation == "Invasive_Tumor")
coords_all <- as.matrix(iss_meta[, c("x_centroid", "y_centroid")])

# 2. KNN Search
nn_knn <- nn2(data = coords_all, query = coords_all[invasive_idx,], k = iss_params$knn)

# 3. Calculate Fraction
is_tumour <- iss_meta$Annotation %in% c("Invasive_Tumor", "Prolif_Invasive_Tumor")
neighbour_indices <- nn_knn$nn.idx[,-1] # remove self
perc_tumours <- rowMeans(matrix(is_tumour[neighbour_indices], nrow = nrow(neighbour_indices))) # mean of boolean vector = fraction of tumour neighbours

# 4. Assign back
iss_meta$perc_tumours <- NA_real_
iss_meta$perc_tumours[invasive_idx] <- perc_tumours

cat("KNN Classification took:", round(Sys.time() - start_time, 2))

# 5. Classify
iss_meta$surface_class_nn <- ifelse(
  is.na(iss_meta$perc_tumours), "Other",
  ifelse(iss_meta$perc_tumours < iss_params$threshold, "Surface", "Core")
)

table(iss_meta$surface_class_nn)
```

#### KNN Method Plots
```{r, fig.width=7.87*1.75, fig.height = 6.5*1.75, dpi=300, dev='tiff', out.width='100%'}
p3 <- ggplot(iss_meta, aes(x = y_centroid, y = x_centroid, color = surface_class_nn)) +
    # Layer 1: Plot only "Other" first
    geom_point(data = subset(iss_meta, surface_class_nn == "Other"), 
               size = 0.01) +
    # Layer 2: Plot everything else on top
    geom_point(data = subset(iss_meta, surface_class_nn != "Other"), 
               size = 0.01) +
    scale_color_manual(values = c("Surface" = "#C90065", "Core" = "#fac0da", "Other" = "grey75")) +
    # Swap xlim to ylim and apply reversal to the new y-axis
    coord_fixed(ylim = c(3850, 0)) +
    theme_minimal() +
    guides(color = guide_legend(override.aes = list(size = 2))); p3

ggsave(file.path(fig_subdir, "p3_ME_annotations_knn_method.png"), plot = p3, dpi = 300)
```

# 4.Tumour Cell depth Method
```{r}
iss_meta$tumour_depth <- NA_real_

#logic: Surface = 0, Core = dist to nearest Surface cell
is_surface <- iss_meta$surface_class_radius == "Surface"
is_core <- iss_meta$surface_class_radius == "Core"

iss_meta$tumour_depth[is_surface] <- 0

if (any(is_core) && any(is_surface)) {
  coords_surface <- as.matrix(iss_meta[is_surface, .(x_centroid, y_centroid)])
  coords_core <- as.matrix(iss_meta[is_core, .(x_centroid, y_centroid)])
  
  # Find nearest neighbour in "Surface" set for every "Core" cell
  nn_dist <- nn2(data = coords_surface, query = coords_core, k = 1)
  
  iss_meta$tumour_depth[is_core] <- nn_dist$nn.dists[, 1]
}

summary(iss_meta[iss_meta$surface_class_radius == "Core",]$tumour_depth)
```

#### Tumour Cell depth Method Plots
```{r, fig.width=7.87*1.75, fig.height = 6.5*1.75, dpi=300, dev='tiff', out.width='100%'}
p4 <- ggplot(iss_meta, aes(x = y_centroid, y = x_centroid)) +
    # Layer 1: Plot "Other" (NA depth) first as grey
    geom_point(data = subset(iss_meta, is.na(tumour_depth)), 
               color = "grey75",
               size = 0.01) +
    # Layer 2: Plot Tumour cells (Valid depth) on top
    geom_point(data = subset(iss_meta, !is.na(tumour_depth)), 
               aes(color = tumour_depth),
               size = 0.01) +
    # Use the same palette as your previous function
    scale_color_gradientn(colors = paletteer::paletteer_c("grDevices::Blue-Red 3", 30)) +
    # Swap xlim to ylim and apply reversal to the new y-axis
    coord_fixed(ylim = c(3850, 0)) +
    theme_minimal() +
    labs(color = "Depth"); p4

ggsave(file.path(fig_subdir, "p4_ME_annotations_depth_method.png"), plot = p4, dpi = 300)
```

#### Annotate Shallow Core Cells
```{r}
# 1. Create a new categorical column for plotting
iss_meta$depth_category <- "Other"

# 2. Assign Surface cells (Depth 0)
iss_meta$depth_category[iss_meta$surface_class_radius == "Surface"] <- "Surface"

# 3. Assign Shallow Core (Depth between 0 and 5)
# We must ensure we only pick 'Core' cells, otherwise 'Surface' (depth=0) gets overwritten
iss_meta$depth_category[iss_meta$surface_class_radius == "Core" & iss_meta$tumour_depth <= 20] <- "Shallow Core"

# 4. Assign Deep Core (Depth > 5)
iss_meta$depth_category[iss_meta$surface_class_radius == "Core" & iss_meta$tumour_depth > 20] <- "Deep Core"

# Check the counts
table(iss_meta$depth_category)
```
```{r, fig.width=7.87*1.75, fig.height = 6.5*1.75, dpi=300, dev='tiff', out.width='100%'}
p5 <- ggplot(iss_meta, aes(x = y_centroid, y = x_centroid, color = depth_category)) +
    # Layer 1: Plot only "Other" first
    geom_point(data = subset(iss_meta, surface_class_nn == "Other"), 
               size = 0.01) +
    # Layer 2: Plot everything else on top
    geom_point(data = subset(iss_meta, surface_class_nn != "Other"), 
               size = 0.01) +
    scale_color_manual(values = c("Surface" = "#C90065", "Deep Core" = "#fac0da", "Shallow Core" = "darkblue", "Other" = "grey75")) +
    # Swap xlim to ylim and apply reversal to the new y-axis
    coord_fixed(ylim = c(3850, 0)) +
    theme_minimal() +
    guides(color = guide_legend(override.aes = list(size = 2))); p5

ggsave(file.path(fig_subdir, "p5_identify_shallow_core_cells.png"), plot = p5, dpi = 300)
```

# 5. Gene Expression Clustering Method
```{r}
# 1. Create iss seurat object
iss_obj <- CreateSeuratObject(counts = iss_expr, meta.data = as.data.frame(iss_meta))
iss_obj_invasive <- subset(iss_obj, subset = Annotation == "Invasive_Tumor")

# 2. Standard Workflow
iss_obj_invasive <- iss_obj_invasive %>%
  NormalizeData(verbose = F) %>%
  FindVariableFeatures(verbose = F) %>%
  ScaleData(verbose = F) %>%
  RunPCA(verbose = F) %>%
  FindNeighbors(dims = 1:10, verbose = F) %>%
  FindClusters(resolution = 0.4, algorithm = 4, verbose = F) %>%
  RunUMAP(dims = 1:10, verbose = F)

print("Standard Workflow Complete")

# 3. Visualise Clusters
p6 <- DimPlot(iss_obj_invasive, label = F) +
  scale_color_viridis_d(option = "turbo") +
  ggtitle("Leiden Clustering"); p6

# 4. Map Clusters back to Metadata
cluster_map <- Idents(iss_obj_invasive)
iss_meta$cluster <- as.character(cluster_map[match(iss_meta$cell_id, names(cluster_map))])

ggsave(file.path(fig_subdir, "p6_leiden_cluster_tumour_cells.png"), plot = p6, dpi = 300)
```

#### Clustering Method Plots
```{r, fig.width=7.87*1.75, fig.height = 6.5*1.75, dpi=300, dev='tiff', out.width='100%'}
# Get turbo colour palette
clusters <- sort(unique(na.omit(iss_meta$cluster)))
n_clusters <- length(clusters)
turbo_cols <- viridis::viridis_pal(option = "turbo")(n_clusters)
names(turbo_cols) <- clusters

p7 <- ggplot(iss_meta, aes(x = y_centroid, y = x_centroid)) +
    # Layer 1: Plot "Other" (NA cluster) first as grey
    geom_point(data = subset(iss_meta, is.na(cluster)), 
               color = "white", 
               size = 0.01) +
    # Layer 2: Plot Clusters on top
    geom_point(data = subset(iss_meta, !is.na(cluster)), 
               aes(color = cluster), 
               size = 0.01) +
    # Use the Turbo palette (Discrete version)
    scale_color_viridis_d(option = "turbo") +
    # Swap xlim to ylim and apply reversal to the new y-axis
    coord_fixed(ylim = c(3850, 0)) +
    theme_minimal() +
    guides(color = guide_legend(override.aes = list(size = 2)))

p7

ggsave(file.path(fig_subdir, "p7_ME_annotations_cluster_method.png"), 
       plot = p7, dpi = 300, width = 7.87*1.75, height = 6.5*1.75)
```
```{r}
# 5. classify based on clusters (manual hard-code annotation)
iss_meta <- iss_meta %>%
  mutate(surface_class_clusters = case_when(
    cluster %in% c("1", "3", "4", "5") ~ "Core",
    cluster %in% c("2", "7") ~ "Surface",
    TRUE ~ "Other"
  ))

# Add new cluster metadata
iss_obj_invasive$surface_class_clusters <- iss_meta$surface_class_clusters[match(Cells(iss_obj_invasive), iss_meta$cell_id)]
```

```{r, fig.width=7.87*1.75, fig.height = 6.5*1.75, dpi=300, dev='tiff', out.width='100%'}
p8 <- ggplot(iss_meta, aes(x = y_centroid, y = x_centroid, color = surface_class_clusters)) +
    # Layer 1: Plot only "Other" first
    geom_point(data = subset(iss_meta, surface_class_clusters == "Other"), 
               size = 0.01) +
    # Layer 2: Plot everything else on top
    geom_point(data = subset(iss_meta, surface_class_clusters != "Other"), 
               size = 0.01) +
    scale_color_manual(values = c("Surface" = "#C90065", "Core" = "#fac0da", "Other" = "white")) +
    # Swap xlim to ylim and apply reversal to the new y-axis
    coord_fixed(ylim = c(3850, 0)) +
    theme_minimal() +
    guides(color = guide_legend(override.aes = list(size = 2)))

p8

ggsave(file.path(fig_subdir, "p7_ME_annotations_cluster_method_labelled.png"), 
       plot = p8, dpi = 300, width = 7.87*1.75, height = 6.5*1.75)
```

# 6. Save Data
```{r}
# Save RDS
saveRDS(iss_obj_invasive, file ="/Users/glero527/Documents/microenvironments/01_data/janesick_2023/processed/iss_obj_invasive.RDS")
saveRDS(iss_meta, file = "/Users/glero527/Documents/microenvironments/01_data/janesick_2023/processed/iss_meta.RDS")
```