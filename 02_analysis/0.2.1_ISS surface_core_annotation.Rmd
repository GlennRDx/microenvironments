---
output:
  pdf_document:
    latex_engine: xelatex
geometry: margin=0.2in
---

```{r setup, include=FALSE, message = FALSE, warning = FALSE}
# Load config.R
source("config.R") 

# Set root directory using the variable from config
knitr::opts_knit$set(root.dir = data_dir)

# Figures Folder
fig_subdir <- file.path(figs_dir, "0.2.1")
if(!dir.exists(fig_subdir)) dir.create(fig_subdir, recursive = TRUE)

# Load libraries
library(tidyverse, quietly = T) # CRAN
library(Matrix, quietly = T) # CRAN
library(ggplot2, quietly = T) # CRAN
library(data.table, quietly = T) # CRAN
library(Seurat, quietly = T) # CRAN
library(dplyr, quietly = T) # CRAN
library(viridis, quietly = T) # CRAN
library(sctransform, quietly = T) # CRAN
library(RANN, quietly = T) # CRAN
library(ggrastr, quietly = T) # CRAN
library(cowplot)
library(paletteer)
library(scry, quietly = T) # bioconductor
library(SingleCellExperiment, quietly = T) # bioconductor
```

```{r}
# Load data
iss_expr <- readRDS("janesick_2023/raw_clean/iss_expr_clean.RDS")
iss_meta <- readRDS("janesick_2023/raw_clean/iss_meta_clean.RDS")
setDT(iss_meta) # Set to data.table for speed
```

# Plotting function
```{r}
plot_surface_classification <- function(data, colour_col,
                                        show_zoom = FALSE,
                                        centre_x = iss_params$centre_x,
                                        centre_y = iss_params$centre_y,
                                        radius = iss_params$radius,
                                        custom_colours = NULL,
                                        continuous = FALSE,
                                        base_size = 1,
                                        title = "") {
  
  
  
  # 1. Main Spatial Plot w/ Classifications (p1)
  p1 <- ggplot(data, aes(x = x_centroid, y = y_centroid)) +
    scale_x_reverse() +
    theme_minimal() +
    labs(title = title) +
    theme(
      legend.position = "bottom",
      plot.margin = margin(0,0,0,0),
      plot.title = element_text(hjust = 0.5, face = "bold", size = 14 * base_size),
      axis.title = element_text(size = 12 * base_size),
      axis.text = element_text(size = 10 * base_size),
      legend.title = element_text(size = 11 * base_size),
      legend.text = element_text(size = 10 * base_size)
    )
    
  # Add points (Continuous vs Discrete)
  if (continuous) {
    p1 <- p1 +geom_point(aes_string(color = colour_col), size = 0.01, alpha = 1) +
      scale_color_gradientn(colors = paletteer_c("grDevices::Blue-Red 3", 30), na.value = "grey75")
  } else {
    p1 <- p1 + geom_point(aes_string(color = colour_col), size = 0.01, alpha = 1) +
      guides(color = guide_legend(override.aes = list(shape = 16, size = 3)))
    
    if(!is.null(custom_colours)) {
      p1 <- p1 + scale_color_manual(values = custom_colours, na.value = "grey75")
    }
  }
  #Return the only the main plot if no zoom is requested
  if (!show_zoom) {
    return(p1)
  }
  
  
  
  # 2. Create zoomed in plot showing neighbourhood radius
  circle <- data.frame(
    x = centre_x + radius * cos(seq(0, 2*pi, length.out = 500)),
    y = centre_y + radius * sin(seq(0, 2*pi, length.out = 500))
  )
  
  # add small circle to the main plot (to show where is being zoomed)
  p1 <- p1 + geom_path(data = circle, aes(x = x, y = y), color = "black", linewidth = 0.3)
  
  # Create zoomed in plot (p2)
  zoom_margin <- 2.5 * radius
  p2 <- ggplot(data, aes(x = x_centroid, y = y_centroid)) + 
    geom_path(data = circle, aes(x = x, y = y), color = "black", linewidth = 0.5) +
    scale_x_reverse() +
    coord_fixed(xlim = c(centre_x - zoom_margin, centre_x + zoom_margin),
                ylim = c(centre_y - zoom_margin, centre_y + zoom_margin)) +
    labs(x = NULL, y = NULL, title = "Zoomed View") +
    theme_bw() +
    theme(
      legend.position = "none", 
      plot.background = element_rect(fill = "white", color = "black", linewidth = 0.5),
      panel.grid = element_blank(),
      axis.text = element_text(size = 6 * base_size),
      axis.title = element_text(size = 7 * base_size), # In case labels are added later
      plot.title = element_text(size = 8 * base_size, hjust = 0.5)
    )
    
  
  # Add points to inset
   if (continuous) {
     p2 <- p2 + geom_point(aes_string(color = colour_col), size = 2 * base_size, alpha = 0.8, shape = 16) +
       scale_color_gradientn(colors = paletteer_c("grDevices::Blue-Red 3", 30), na.value = "grey75")
   } else {
     p2 <- p2 + geom_point(aes_string(color = colour_col), size = 2 * base_size, alpha = 0.8, shape = 16)
      if(!is.null(custom_colours)) {
        p2 <- p2 + scale_color_manual(values = custom_colours, na.value = "grey75")
      }
   }
  
  # combine with cowplot
  plot_ratio <- 7.87 / 6.5
  final_plot <- ggdraw(p1) +
    draw_plot(p2, x = 0.12, y = 0.20, width = 0.3, height = 0.3 * plot_ratio)
  
  return(final_plot)
}
```
  
# METHOD 1: RADIUS SEARCH
```{r}
start_time <- Sys.time()

# 1. Prep coordinates
coords <- iss_meta[, .(x_centroid, y_centroid)] #Q: what does the period do?

# 2. Perform radius search (returns the indices)
nn_result <- nn2(data = coords, query = coords, searchtype = "radius", radius = iss_params$radius, k = 200)

# 3. Identify target cell indices (invasice tumour cells)
invasive_idx <- which(iss_meta$Annotation == "Invasive_Tumor")
is_tumour_neighbour <- iss_meta$Annotation %in% c("Invasive_Tumor", "Prolif_Invasive_Tumor")

# 4. Calculate the fraction (vectorised for speed)
classification_vec <- vapply(invasive_idx, function(i) {
  
  nb_idx <- nn_result$nn.idx[i, ] # get the neighbour ids
  nb_idx <- nb_idx[nb_idx != 0 & nb_idx != i] # exclude self and 0 padding added by nn2
  if (length(nb_idx) == 0) return("Surface") # Edge case, if a cell has no neighbours in radius, it's a surface cell
  
  frac <- sum(is_tumour_neighbour[nb_idx]) / length(nb_idx) # Calculate Fraction
  
  if (frac > iss_params$threshold) "Core" else "Surface"
}, FUN.VALUE = character(1))

# 5. enrich metadata
iss_meta$surface_class_radius <- "Other" # Set everything to "Other"
iss_meta$surface_class_radius[invasive_idx] <- classification_vec # Overwrite "Other" with new Surface/Core classes

neighbour_counts <- rowSums(nn_result$nn.idx[invasive_idx, ] != 0) - 1
iss_meta$neighbour_count <- NA
iss_meta$neighbour_count[invasive_idx] <- neighbour_counts

end_time <- Sys.time()

cat("Classification took:", round(end_time - start_time, 2))

table(iss_meta$surface_class_radius)
```

```{r}
mean_val <- mean(iss_meta$neighbour_count, na.rm = T)
p1 <- ggplot(subset(iss_meta, !is.na(neighbour_count)), aes(x = neighbour_count)) +
  geom_bar(fill = "#AA4A44", color = "black", width = 1, linewidth = 0) +
  
  # Add the vertical line for the mean
  geom_vline(aes(xintercept = mean_val), color = "black", linetype = "dashed", linewidth = 1) +
  
  theme_minimal() +
  labs(
    title = "Distribution of Counts of cells with n neighbours within radius",
    subtitle = paste("Radius =", iss_params$radius, "\nMean n =", round(mean_val, 2)),
    x = "Number of Neighbours in Radius",
    y = "Count of Cells"
  )

ggsave(
  filename = file.path(fig_subdir, "p1_dist_of_counts_of_cells_with_n_neighbours_in_radius.png"),
  plot = p1,
  dpi = 300,
  scale = 2,
  width = 7.87,
  height = 7
)
```

```{r, fig.width=7.87*2, fig.height = 6.5*2, dpi=300, dev='tiff', out.width='100%'}
ggplot(iss_meta, aes(x = x_centroid, y = y_centroid, color = surface_class_radius)) +
    # Layer 1: Plot only "Other" first
    geom_point(data = subset(iss_meta, surface_class_radius == "Other"), 
               size = 0.01) +
    # Layer 2: Plot everything else on top
    geom_point(data = subset(iss_meta, surface_class_radius != "Other"), 
               size = 0.01) +
    scale_color_manual(values = c("Surface" = "#C90065", "Core" = "#fac0da", "Other" = "grey75")) +
    coord_fixed() +
    scale_x_reverse() + 
    theme_minimal() +
    guides(color = guide_legend(override.aes = list(size = 1)))
```


# METHOD 2: KNN SEARCH
```{r}
# 1. Get Indices
invasive_idx <- which(iss_meta$Annotation == "Invasive_Tumor")
coords_all <- as.matrix(iss_meta[, c("x_centroid", "y_centroid")])

# 2. KNN Search
nn_knn <- nn2(data = coords_all, query = coords_all[invasive_idx,], k = iss_params$knn)

# 3. Calculate Fraction
is_tumour <- iss_meta$Annotation %in% c("Invasive_Tumor", "Prolif_Invasive_Tumor")
neighbour_indices <- nn_knn$nn.idx[,-1] # remove self
perc_tumours <- rowMeans(matrix(is_tumour[neighbour_indices], nrow = nrow(neighbour_indices))) # mean of boolean vector = fraction of tumour neighbours

# 4. Assign back
iss_meta$perc_tumours <- NA_real_
iss_meta$perc_tumours[invasive_idx] <- perc_tumours

cat("KNN Classification took:", round(Sys.time() - start_time, 2))

# 5. Classify
iss_meta$surface_class_nn <- ifelse(
  is.na(iss_meta$perc_tumours), "Other",
  ifelse(iss_meta$perc_tumours < iss_params$threshold, "Surface", "Core")
)

table(iss_meta$surface_class_nn)
```

```{r, fig.width=7.87, fig.height = 6.5, dpi=300, dev='tiff', out.width='100%'}
p3 <- plot_surface_classification(
  data = iss_meta,
  colour_col = "surface_class_nn",
  show_zoom = F,
  custom_colours = c("Surface" = "#C90065", "Core" = "#fac0da", "Other" = "grey75")
)

ggsave(
  filename = file.path(fig_subdir, "p3_ME_annotations_knn_method.png"),
  plot = p3,
  dpi = 300,
  width = 4*7.87,
  height = 4*6,
  scale  = 0.5
)
```

```{r, fig.width=7.87*1.75, fig.height = 6.5*1.75, dpi=300, dev='tiff', out.width='100%'}
ggplot(iss_meta, aes(x = y_centroid, y = x_centroid, color = surface_class_nn)) +
    # Layer 1: Plot only "Other" first
    geom_point(data = subset(iss_meta, surface_class_nn == "Other"), 
               size = 0.01) +
    # Layer 2: Plot everything else on top
    geom_point(data = subset(iss_meta, surface_class_nn != "Other"), 
               size = 0.01) +
    scale_color_manual(values = c("Surface" = "#C90065", "Core" = "#fac0da", "Other" = "grey75")) +
    # Swap xlim to ylim and apply reversal to the new y-axis
    coord_fixed(ylim = c(3850, 0)) +
    theme_minimal() +
    guides(color = guide_legend(override.aes = list(size = )))
```

# METHOD 3: TUMOUR CELL DEPTH GRADIENT
```{r}
iss_meta$tumour_depth <- NA_real_

#logic: Surface = 0, Core = dist to nearest Surface cell
is_surface <- iss_meta$surface_class_radius == "Surface"
is_core <- iss_meta$surface_class_radius == "Core"

iss_meta$tumour_depth[is_surface] <- 0

if (any(is_core) && any(is_surface)) {
  coords_surface <- as.matrix(iss_meta[is_surface, .(x_centroid, y_centroid)])
  coords_core <- as.matrix(iss_meta[is_core, .(x_centroid, y_centroid)])
  
  # Find nearest neighbour in "Surface" set for every "Core" cell
  nn_dist <- nn2(data = coords_surface, query = coords_core, k = 1)
  
  iss_meta$tumour_depth[is_core] <- nn_dist$nn.dists[, 1]
}

summary(iss_meta[iss_meta$surface_class_radius == "Core",]$tumour_depth)
```
```{r, fig.width=7.87, fig.height = 6.5, dpi=300, dev='tiff', out.width='100%'}
p4 <- plot_surface_classification(
  data = iss_meta,
  colour_col = "tumour_depth",
  continuous = T
)

ggsave(
  filename = file.path(fig_subdir, "p4_ME_annotations_depth_method.png"),
  plot = p4,
  dpi = 300,
  width = 4*7.87,
  height = 4*6,
  scale  = 0.5
)
```

```{r}
# 1. Create a new categorical column for plotting
iss_meta$depth_category <- "Other"

# 2. Assign Surface cells (Depth 0)
iss_meta$depth_category[iss_meta$surface_class_radius == "Surface"] <- "Surface"

# 3. Assign Shallow Core (Depth between 0 and 5)
# We must ensure we only pick 'Core' cells, otherwise 'Surface' (depth=0) gets overwritten
iss_meta$depth_category[iss_meta$surface_class_radius == "Core" & iss_meta$tumour_depth <= 15] <- "Shallow Core"

# 4. Assign Deep Core (Depth > 5)
iss_meta$depth_category[iss_meta$surface_class_radius == "Core" & iss_meta$tumour_depth > 15] <- "Deep Core"

# Check the counts
table(iss_meta$depth_category)
```

```{r, fig.width=7.87, fig.height = 6.5, dpi=300, dev='tiff', out.width='100%'}
p5 <- plot_surface_classification(
  data = iss_meta,
  colour_col = "depth_category",
  continuous = FALSE,
  custom_colours = c(
    "Surface" = "#C90065",       # Standard Pink
    "Shallow Core" = "darkblue",     # HIGHLIGHT COLOR (Bright and distinct)
    "Deep Core" = "#fac0da",     # Lighter Pink (Background core)
    "Other" = "grey75"
  ),
  title = "Highlighting Shallow Core Cells (Depth â‰¤ 5)"
)

ggsave(
  filename = file.path(fig_subdir, "p5_identify_shallow_core_cells.png"),
  plot = p5,
  dpi = 300,
  width = 4*7.87,
  height = 4*6,
  scale  = 0.5
)
```

```{r}
table(iss_meta$depth_category)
```


```{r, fig.width=7.87*1.75, fig.height = 6.5*1.75, dpi=300, dev='tiff', out.width='100%'}
ggplot(iss_meta, aes(x = y_centroid, y = x_centroid, color = depth_category)) +
    # Layer 1: Plot only "Other" first
    geom_point(data = subset(iss_meta, surface_class_nn == "Other"), 
               size = 0.01) +
    # Layer 2: Plot everything else on top
    geom_point(data = subset(iss_meta, surface_class_nn != "Other"), 
               size = 0.01) +
    scale_color_manual(values = c("Surface" = "#C90065", "Deep Core" = "#fac0da", "Shallow Core" = "darkblue", "Other" = "grey75")) +
    # Swap xlim to ylim and apply reversal to the new y-axis
    coord_fixed(ylim = c(3850, 0)) +
    theme_minimal() +
    guides(color = guide_legend(override.aes = list(size = 2)))
```

# METHOD 4: GENE EXPRESSION CLUSTERING
```{r}
# 1. Create iss seurat object
iss_obj <- CreateSeuratObject(counts = iss_expr, meta.data = as.data.frame(iss_meta))
iss_obj_invasive <- subset(iss_obj, subset = Annotation == "Invasive_Tumor")

# 2. Standard Workflow
iss_obj_invasive <- iss_obj_invasive %>%
  NormalizeData() %>%
  FindVariableFeatures() %>%
  ScaleData() %>%
  RunPCA() %>%
  FindNeighbors(dims = 1:10) %>%
  FindClusters(resolution = 0.3, algorithm = 4) %>%
  RunUMAP(dims = 1:10)

# 3. Visualise Clusters
p6 <- DimPlot(iss_obj_invasive, label = F) +
  scale_color_viridis_d(option = "turbo") +
  ggtitle("Leiden Clustering")

# 4. Map Clusters back to Metadata
cluster_map <- Idents(iss_obj_invasive)
iss_meta$cluster <- as.character(cluster_map[match(iss_meta$cell_id, names(cluster_map))])

# 5. classify based on clusters (manual hard-code annotation)
iss_meta <- iss_meta %>%
  mutate(surface_class_clusters = case_when(
    cluster %in% c("1", "2") ~ "Core",
    cluster %in% c("3") ~ "Surface",
    TRUE ~ NA_character_
  ))

ggsave(
  filename = file.path(fig_subdir, "p6_leiden_cluster_tumour_cells.png"),
  plot = p6,
  dpi = 300,
  width = 7.87,
  height = 6,
  scale  = 0.5
)
```
```{r, fig.width=7.87, fig.height = 6.5, dpi=300, dev='tiff', out.width='100%'}
# Get turbo colour palette
clusters <- sort(unique(na.omit(iss_meta$cluster)))
n_clusters <- length(clusters)
turbo_cols <- viridis::viridis_pal(option = "turbo")(n_clusters)
names(turbo_cols) <- clusters

p7 <- plot_surface_classification(data = iss_meta,
                            colour_col = "cluster",
                            custom_colours = turbo_cols)

ggsave(
  filename = file.path(fig_subdir, "p7_ME_annotations_cluster_method.png"),
  plot = p7,
  dpi = 300,
  width = 4*7.87,
  height = 4*6,
  scale  = 0.5
)
```


# SAVE CLASSIFICATIONS TO SEURAT OBJECT
- iss_obj_invasive already has gene expression counts, radius/KNN/depth metadata, and PCA/UMAP coords
- Missing: "surface_class_clusters". So we add that back then we can save the RDS files.
```{r}
# Add new cluster metadata
iss_obj_invasive$surface_class_clusters <- iss_meta$surface_class_clusters[match(Cells(iss_obj_invasive), iss_meta$cell_id)]

# Save RDS
saveRDS(iss_obj_invasive, file = "janesick_2023/processed/iss_obj_invasive.RDS")
saveRDS(iss_meta, file = "janesick_2023/processed/iss_meta.RDS")
```

