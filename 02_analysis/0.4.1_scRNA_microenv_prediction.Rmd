---
output:
  pdf_document:
    latex_engine: xelatex
geometry: margin=0.2in
---

# 1. Load files & Libraries
```{r setup, include=FALSE, message = FALSE, warning = FALSE}
# Load config.R
source("config.R") 

# Set root directory using the variable from config
knitr::opts_knit$set(root.dir = data_dir)

# Define Figure Directory 
fig_subdir <- file.path(figs_dir, "0.4.1")
if(!dir.exists(fig_subdir)) dir.create(fig_subdir, recursive = TRUE)

# Load libraries
library(MASS)
library(dplyr)
library(data.table)
library(Seurat)
library(ggplot2)
library(tidyverse)
```

```{r}
# load lda models
fit_lda <- readRDS("janesick_2023/processed/fit_lda.RDS")
fit_lda_val <- readRDS("janesick_2023/processed/fit_lda_val.RDS")

# load gene lists
shared_genes <- readRDS("janesick_2023/processed/shared_genes.RDS")
train_genes <- readRDS("janesick_2023/processed/train_genes.RDS")

# Load Data
wts_obj <- readRDS("janesick_2023/processed/wts_obj_processed.RDS")
wts_expr_clean <- fread("janesick_2023/raw/scRNAseq_data_quantile_matched.txt") %>% as.data.frame()
```

# 2. Replace counts with quantile matched counts
```{r}
# 1. clean up quant. matched data
rownames(wts_expr_clean) <- wts_expr_clean$V1
wts_expr_clean$V1 <- NULL

# 2. Remove genes which are not shared between ISS and WTS
wts_obj <- subset(wts_obj, features = shared_genes)

# 3. Reorder/subset the new matrix to match the Seurat object's cells/genes
wts_expr_clean <- wts_expr_clean[rownames(wts_obj), colnames(wts_obj)]

# 4. covert quantile matched counts to sparse matrix
counts_matrix_sparse <- as(as.matrix(wts_expr_clean), "dgCMatrix")

# 5. Replace old RAW counts with quantile matched sparse matrix
wts_obj[["RNA"]] <- SetAssayData(object = wts_obj[["RNA"]], 
                             layer = "counts", 
                             new.data = counts_matrix_sparse)

# 6. Filter to invasive tumour cells only
wts_obj_invasive <- subset(wts_obj, subset = Annotation %in% "Invasive_Tumor")
```

# 3. Normalise (log + CPM)
```{r}
counts <- GetAssayData(wts_obj_invasive, assay = "RNA", layer = "counts")

cpm_counts <- t(t(counts) / colSums(counts)) * 1e6

log_cpm_counts <- log1p(cpm_counts)

# Replace into data layer
wts_obj_invasive <- SetAssayData(
  object = wts_obj_invasive, 
  layer = "data", 
  new.data = log_cpm_counts
)
```

# Extract normalised count matrix in preparation for prediction
```{r}
inv_tumour_expr <- as.data.frame(t(as.matrix(LayerData(wts_obj_invasive, layer = "data"))))
```


# 5. Apply LDA Predictions
```{r}
# --- Prediction 1: Final Model (100% genes) ---
# Ensure columns match shared_genes
data_final <- inv_tumour_expr[, shared_genes]
pred_final <- predict(fit_lda, newdata = data_final)


# --- Prediction 2: Validation Model (2/3 genes) ---
# Ensure columns match train_genes only
data_val <- inv_tumour_expr[, train_genes]
pred_val <- predict(fit_lda_val, newdata = data_val)


# --- compile Results ---
results_df <- data.frame(
  cell_id = rownames(inv_tumour_expr),
  
  # Final Model Results
  microenv_prediction = pred_final$class,
  prob_core = pred_final$posterior[, "Core"],
  prob_surface = pred_final$posterior[, "Surface"],
  LD1 = pred_final$x[, 1],
  
  # Validation Model Results
  microenv_lda_val = pred_val$class,
  
  stringsAsFactors = FALSE
)

# Filter Logic (Based on Final Model)
results_df <- results_df %>%
  mutate(max_prob = pmax(prob_core, prob_surface),
         status = ifelse(max_prob >= prediction_params$prob_threshold, "High Confidence", "Ambiguous"))

results_df_filtered <- results_df %>%
  filter(status == "High Confidence")
```

# 6. Plot LDA
```{r}
# 1. Prepare Stats
n_high_conf_core <- sum(results_df$microenv_prediction == "Core" & results_df$status == "High Confidence")
n_high_conf_surf <- sum(results_df$microenv_prediction == "Surface" & results_df$status == "High Confidence")
n_ambiguous <- sum(results_df$status == "Ambiguous")

stats_label <- paste0(
  "High Conf. Core: ", n_high_conf_core, "\n",
  "High Conf. Surface: ", n_high_conf_surf, "\n",
  "Ambiguous: ", n_ambiguous
)

# 2. Plot
p_pred <- ggplot(results_df, aes(x = LD1, fill = microenv_prediction)) +
  geom_density(alpha = 0.5) +
  annotate("label", x = Inf, y = Inf, label = stats_label, 
           hjust = 1.1, vjust = 1.1, size = 3.5, 
           fill = "white", alpha = 0.8, color = "black") +
  theme_minimal() +
  labs(
    title = "LDA Projection of scRNA-seq (Final Model)",
    x = "LD1", 
    y = "Density",
    fill = "Predicted Class"
  ) +
  theme(plot.title = element_text(face = "bold", size = 12)); p_pred

# Save
ggsave(filename = file.path(fig_subdir, paste0("scRNA_LDA_projection_", classification_method, ".png")), plot = p_pred, dpi = 300)
```

# 7. Add Predictions to Seurat Object
```{r}
# Create metadata dataframe
meta_to_add <- results_df_filtered %>%
  tibble::remove_rownames() %>%
  dplyr::select(cell_id, microenv_prediction, microenv_lda_val, prob_core, LD1) %>%
  tibble::column_to_rownames("cell_id")

# 1. Add to invasive object
wts_obj_invasive <- AddMetaData(wts_obj_invasive, metadata = meta_to_add)

# 2. Add to full object (re-load original processed object to be safe)
wts_obj_full <- readRDS("janesick_2023/processed/wts_obj_processed.RDS")
wts_obj_full <- AddMetaData(wts_obj_full, metadata = meta_to_add)
```

# 8. Save
```{r}
saveRDS(wts_obj_invasive, file = "janesick_2023/processed/wts_obj_invasive.RDS")
saveRDS(wts_obj_full, file = "janesick_2023/processed/wts_obj_processed_predicted.RDS")
```

###########
```{r}
hist(wts_obj_invasive$nCount_RNA, breaks = 200) 
```

```{r}
plot_data <- wts_obj_invasive@meta.data
p_bias_check <- plot_data %>%
  filter(!is.na(microenv_prediction)) %>%
  ggplot(aes(x = microenv_prediction, y = nCount_RNA, fill = microenv_prediction)) +
  
  # Violin for distribution shape
  geom_violin(trim = FALSE, alpha = 0.6, scale = "width") +
  
  # Boxplot inside to show median and quartiles clearly
  geom_boxplot(width = 0.1, fill = "white", outlier.shape = NA) +
  
  # Add points (jittered) if you want to see individual cells (optional, can be messy if N is large)
  # geom_jitter(width = 0.1, size = 0.5, alpha = 0.2) + 
  
  theme_minimal() +
  scale_fill_brewer(palette = "Set1") + # Or use specific colors like c("Core"="blue", "Surface"="red")
  labs(
    title = "Sequencing Depth Bias Check",
    subtitle = "",
    x = "Predicted Class",
    y = "Sequencing Depth (Total UMIs)",
    fill = "Class"
  ) +
  theme(legend.position = "none")
p_bias_check
```

```{r}
# Create stacked barplot of predictions by depth
barplot(table(wts_obj_invasive$microenv_prediction, cut(wts_obj_invasive$nCount_RNA, 200)),
        legend = TRUE, 
        las = 2, 
        main = "Predictions by Depth")
```

```{r}
barplot(prop.table(table(wts_obj_invasive$microenv_prediction, cut(wts_obj_invasive$nCount_RNA, 200)), 2),
        legend = TRUE, 
        las = 2, 
        main = "Proportion of Predictions by Depth")
```

