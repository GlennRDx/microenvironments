---
output:
  pdf_document:
    latex_engine: xelatex
geometry: margin=0.2in
---

```{r setup, include=FALSE, message = FALSE, warning = FALSE}
# Load config.R
source("/home/glennrdx/Documents/lab_projects/microenvironments/02_analysis/config.R") 

# Set root directory using the variable from config
knitr::opts_knit$set(root.dir = project_root)

# Load libraries
library(tidyverse, quietly = T) # CRAN
library(Matrix, quietly = T) # CRAN
library(ggplot2, quietly = T) # CRAN
library(data.table, quietly = T) # CRAN
library(Seurat, quietly = T) # CRAN
library(dplyr, quietly = T) # CRAN
library(viridis, quietly = T) # CRAN
library(sctransform, quietly = T) # CRAN
library(RANN, quietly = T) # CRAN
library(ggrastr, quietly = T) # CRAN
library(cowplot)
library(paletteer)
library(scry, quietly = T) # bioconductor
library(SingleCellExperiment, quietly = T) # bioconductor
```

```{r}
# Load data
iss_expr <- readRDS("/home/glennrdx/Documents/lab_projects/microenvironments/01_data/janesick_2023/raw_clean/iss_expr_clean.RDS")
iss_meta <- readRDS("/home/glennrdx/Documents/lab_projects/microenvironments/01_data/janesick_2023/raw_clean/iss_meta_clean.RDS")
setDT(iss_meta) # Set to data.table for speed
```

# Plotting function
```{r}
plot_surface_classification <- function(data, colour_col,
                                        show_zoom = FALSE,
                                        centre_x = iss_params$centre_x,
                                        centre_y = iss_params$centre_y,
                                        radius = iss_params$radius,
                                        custom_colours = NULL,
                                        continuous = FALSE,
                                        title = "") {
  
  
  
  # 1. Main Spatial Plot w/ Classifications (p1)
  p1 <- ggplot(data, aes(x = x_centroid, y = y_centroid)) +
    scale_x_reverse() +
    coord_fixed() +
    theme_minimal() +
    labs(title = title) +
    theme(
      legend.position = "bottom",
      plot.margin = margin(0,0,0,0),
      plot.title = element_text(hjust = 0.5, face = "bold")
    )
  # Add points (Continuous vs Discrete)
  if (continuous) {
    p1 <- p1 +geom_point(aes_string(color = colour_col), size = 0.01, alpha = 1, shape = ".") +
      scale_color_gradientn(colors = paletteer_c("grDevices::Blue-Red 3", 30), na.value = "grey75")
  } else {
    p1 <- p1 + geom_point(aes_string(color = colour_col), size = 0.01, alpha = 1, shape = ".") +
      guides(color = guide_legend(override.aes = list(shape = 16, size = 3)))
    
    if(!is.null(custom_colours)) {
      p1 <- p1 + scale_color_manual(values = custom_colours, na.value = "grey75")
    }
  }
  #Return the only the main plot if no zoom is requested
  if (!show_zoom) {
    return(p1)
  }
  
  
  
  # 2. Create zoomed in plot showing neighbourhood radius
  circle <- data.frame(
    x = centre_x + radius * cos(seq(0, 2*pi, length.out = 500)),
    y = centre_y + radius * sin(seq(0, 2*pi, length.out = 500))
  )
  
  # add small circle to the main plot (to show where is being zoomed)
  p1 <- p1 + geom_path(data = circle, aes(x = x, y = y), color = "black", linewidth = 0.3)
  
  # Create zoomed in plot (p2)
  zoom_margin <- 2.5 * radius
  p2 <- ggplot(data, aes(x = x_centroid, y = y_centroid)) + 
    geom_path(data = circle, aes(x = x, y = y), color = "black", linewidth = 0.5) +
    scale_x_reverse() +
    coord_fixed(xlim = c(centre_x - zoom_margin, centre_x + zoom_margin),
                ylim = c(centre_y - zoom_margin, centre_y + zoom_margin)) +
    labs(x = NULL, y = NULL, title = "Zoomed View") +
    theme_bw() +
    theme(
      legend.position = "none", 
      plot.background = element_rect(fill = "white", color = "black", linewidth = 0.5),
      axis.text = element_text(size = 6),
      plot.title = element_text(size = 8, hjust = 0.5),
      panel.grid = element_blank()
    )
  
  # Add points to inset
   if (continuous) {
     p2 <- p2 + geom_point(aes_string(color = colour_col), size = 2, alpha = 0.8, shape = 16) +
       scale_color_gradientn(colors = paletteer_c("grDevices::Blue-Red 3", 30), na.value = "grey75")
   } else {
     p2 <- p2 + geom_point(aes_string(color = colour_col), size = 2, alpha = 0.8, shape = 16)
      if(!is.null(custom_colours)) {
        p2 <- p2 + scale_color_manual(values = custom_colours, na.value = "grey75")
      }
   }
  
  # combine with cowplot
  plot_ratio <- 7.87 / 6.5
  final_plot <- ggdraw(p1) +
    draw_plot(p2, x = 0.12, y = 0.20, width = 0.3, height = 0.3 * plot_ratio)
  
  return(final_plot)
}
```
  
# METHOD 1: RADIUS SEARCH
```{r}
start_time <- Sys.time()

# 1. Prep coordinates
coords <- iss_meta[, .(x_centroid, y_centroid)] #Q: what does the period do?

# 2. Perform radius search (returns the indices)
nn_result <- nn2(data = coords, query = coords, searchtype = "radius", radius = iss_params$radius, k = 200)

# 3. Identify target cell indices (invasice tumour cells)
invasive_idx <- which(iss_meta$Annotation == "Invasive_Tumor")
is_tumour_neighbour <- iss_meta$Annotation %in% c("Invasive_Tumor", "Prolif_Invasive_Tumor")

# 4. Calculate the fraction (vectorised for speed)
classification_vec <- vapply(invasive_idx, function(i) {
  
  nb_idx <- nn_result$nn.idx[i, ] # get the neighbour ids
  nb_idx <- nb_idx[nb_idx != 0 & nb_idx != i] # exclude self and 0 padding added by nn2
  if (length(nb_idx) == 0) return("Surface") # Edge case, if a cell has no neighbours in radius, it's a surface cell
  
  frac <- sum(is_tumour_neighbour[nb_idx]) / length(nb_idx) # Calculate Fraction
  
  if (frac > iss_params$threshold) "Core" else "Surface"
}, FUN.VALUE = character(1))

# 5. enrich metadata
iss_meta$surface_class_radius <- "Other" # Set everything to "Other"
iss_meta$surface_class_radius[invasive_idx] <- classification_vec # Overwrite "Other" with new Surface/Core classes

neighbour_counts <- rowSums(nn_result$nn.idx[invasive_idx, ] != 0) - 1
iss_meta$neighbour_count <- NA
iss_meta$neighbour_count[invasive_idx] <- neighbour_counts

end_time <- Sys.time()

cat("Classification took:", round(end_time - start_time, 2))

table(iss_meta$surface_class_radius)
```

```{r}
mean_val <- mean(iss_meta$neighbour_count, na.rm = T)
ggplot(subset(iss_meta, !is.na(neighbour_count)), aes(x = neighbour_count)) +
  geom_bar(fill = "#AA4A44", color = "black", width = 1, linewidth = 0) +
  
  # Add the vertical line for the mean
  geom_vline(aes(xintercept = mean_val), color = "black", linetype = "dashed", linewidth = 1) +
  
  theme_minimal() +
  labs(
    title = "Distribution of Counts of cells with n neighbours within radius",
    subtitle = paste("Radius =", R, "\nMean n =", round(mean_val, 2)),
    x = "Number of Neighbours in Radius",
    y = "Count of Cells"
  )
```

```{r, fig.width=7.87, fig.height = 6.5, dpi=300, dev='tiff', out.width='100%'}
plot_surface_classification(
  data = iss_meta,
  colour_col = "surface_class_radius",
  centre_x = 3249.27,
  centre_y = 2027.26,
  radius = iss_params$radius,
  show_zoom = T,
  custom_colours = c("Surface" = "#C90065", "Core" = "#fac0da", "Other" = "grey75")
)
```


# METHOD 2: KNN SEARCH
```{r}
# 1. Get Indices
invasive_idx <- which(iss_meta$Annotation == "Invasive_Tumor")
coords_all <- as.matrix(iss_meta[, c("x_centroid", "y_centroid")])

# 2. KNN Search
nn_knn <- nn2(data = coords_all, query = coords_all[invasive_idx,], k = iss_params$knn)

# 3. Calculate Fraction
is_tumour <- iss_meta$Annotation %in% c("Invasive_Tumor", "Prolif_Invasive_Tumor")
neighbour_indices <- nn_knn$nn.idx[,-1] # remove self
perc_tumours <- rowMeans(matrix(is_tumour[neighbour_indices], nrow = nrow(neighbour_indices))) # mean of boolean vector = fraction of tumour neighbours

# 4. Assign back
iss_meta$perc_tumours <- NA_real_
iss_meta$perc_tumours[invasive_idx] <- perc_tumours

cat("KNN Classification took:", round(Sys.time() - start_time, 2))

# 5. Classify
iss_meta$surface_class_nn <- ifelse(
  is.na(iss_meta$perc_tumours), "Other",
  ifelse(iss_meta$perc_tumours < iss_params$threshold, "Surface", "Core")
)

table(iss_meta$surface_class_nn)
```

```{r, fig.width=7.87, fig.height = 6.5, dpi=300, dev='tiff', out.width='100%'}
plot_surface_classification(
  data = iss_meta,
  colour_col = "surface_class_nn",
  show_zoom = F,
  custom_colours = c("Surface" = "#C90065", "Core" = "#fac0da", "Other" = "grey75")
)
```

# METHOD 3: TUMOUR CELL DEPTH GRADIENT
```{r}
iss_meta$tumour_depth <- NA_real_

#logic: Surface = 0, Core = dist to nearest Surface cell
is_surface <- iss_meta$surface_class_radius == "Surface"
is_core <- iss_meta$surface_class_radius == "Core"

iss_meta$tumour_depth[is_surface] <- 0

if (any(is_core) && any(is_surface)) {
  coords_surface <- as.matrix(iss_meta[is_surface, .(x_centroid, y_centroid)])
  coords_core <- as.matrix(iss_meta[is_core, .(x_centroid, y_centroid)])
  
  # Find nearest neighbour in "Surface" set for every "Core" cell
  nn_dist <- nn2(data = coords_surface, query = coords_core, k = 1)
  
  iss_meta$tumour_depth[is_core] <- nn_dist$nn.dists[, 1]
}

summary(iss_meta[iss_meta$surface_class_radius == "Core",]$tumour_depth)
```
```{r, fig.width=7.87, fig.height = 6.5, dpi=300, dev='tiff', out.width='100%'}
plot_surface_classification(
  data = iss_meta,
  colour_col = "tumour_depth",
  continuous = T
)
```

```{r}
# 1. Create a new categorical column for plotting
iss_meta$depth_category <- "Other"

# 2. Assign Surface cells (Depth 0)
iss_meta$depth_category[iss_meta$surface_class_radius == "Surface"] <- "Surface"

# 3. Assign Shallow Core (Depth between 0 and 5)
# We must ensure we only pick 'Core' cells, otherwise 'Surface' (depth=0) gets overwritten
iss_meta$depth_category[iss_meta$surface_class_radius == "Core" & iss_meta$tumour_depth <= 15] <- "Shallow Core"

# 4. Assign Deep Core (Depth > 5)
iss_meta$depth_category[iss_meta$surface_class_radius == "Core" & iss_meta$tumour_depth > 15] <- "Deep Core"

# Check the counts
table(iss_meta$depth_category)
```
```{r, fig.width=7.87, fig.height = 6.5, dpi=300, dev='tiff', out.width='100%'}
plot_surface_classification(
  data = iss_meta,
  colour_col = "depth_category",
  continuous = FALSE,
  custom_colours = c(
    "Surface" = "#C90065",       # Standard Pink
    "Shallow Core" = "darkblue",     # HIGHLIGHT COLOR (Bright and distinct)
    "Deep Core" = "#fac0da",     # Lighter Pink (Background core)
    "Other" = "grey75"
  ),
  title = "Highlighting Shallow Core Cells (Depth â‰¤ 5)"
)
```

# METHOD 4: GENE EXPRESSION CLUSTERING
```{r}
# 1. Create iss seurat object
iss_obj <- CreateSeuratObject(counts = iss_expr, meta.data = as.data.frame(iss_meta))
iss_obj_invasive <- subset(iss_obj, subset = Annotation == "Invasive_Tumor")

# 2. Standard Workflow
iss_obj_invasive <- iss_obj_invasive %>%
  NormalizeData() %>%
  FindVariableFeatures() %>%
  ScaleData() %>%
  RunPCA() %>%
  FindNeighbors(dims = 1:10) %>%
  FindClusters(resolution = 0.3, algorithm = 4) %>%
  RunUMAP(dims = 1:10)

# 3. Visualise Clusters
DimPlot(iss_obj_invasive, label = F) +
  scale_color_viridis_d(option = "turbo") +
  ggtitle("Leiden Clustering")

# 4. Map Clusters back to Metadata
cluster_map <- Idents(iss_obj_invasive)
iss_meta$cluster <- as.character(cluster_map[match(iss_meta$cell_id, names(cluster_map))])

# 5. classify based on clusters (manual hard-code annotation)
iss_meta <- iss_meta %>%
  mutate(surface_class_clusters = case_when(
    cluster %in% c("1", "2") ~ "core",
    cluster %in% c("3") ~ "Surface",
    TRUE ~ NA_character_
  ))
```
```{r, fig.width=7.87, fig.height = 6.5, dpi=300, dev='tiff', out.width='100%'}
# Get turbo colour palette
clusters <- sort(unique(na.omit(iss_meta$cluster)))
n_clusters <- length(clusters)
turbo_cols <- viridis::viridis_pal(option = "turbo")(n_clusters)
names(turbo_cols) <- clusters

plot_surface_classification(data = iss_meta,
                            colour_col = "cluster",
                            custom_colours = turbo_cols)
```


# SAVE CLASSIFICATIONS TO SEURAT OBJECT
- iss_obj_invasive already has gene expression counts, radius/KNN/depth metadata, and PCA/UMAP coords
- Missing: "surface_class_clusters". So we add that back then we can save the RDS files.
```{r}
# Add new cluster metadata
iss_obj_invasive$surface_class_clusters <- iss_meta$surface_class_clusters[match(Cells(iss_obj_invasive), iss_meta$cell_id)]

# Save RDS
saveRDS(iss_obj_invasive, file = "janesick_2023/processed/iss_obj_invasive.RDS")
saveRDS(iss_meta, file = "janesick_2023/processed/iss_meta.RDS")
```

