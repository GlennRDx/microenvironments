---
output:
  pdf_document:
    latex_engine: xelatex
geometry: margin=0.2in
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding,
  output_dir = "/home/glennrdx/Documents/lab_projects/microenvironments/02_output/") })
---

# Load Packages

```{r setup, include=FALSE, message = FALSE, warning = FALSE}
knitr::opts_knit$set(root.dir = "/home/glennrdx/Documents/lab_projects/microenvironments/01_data/")

# Load libraries
library(tidyverse, quietly = T) # CRAN
library(Matrix, quietly = T) # CRAN
library(ggplot2, quietly = T) # CRAN
library(data.table, quietly = T) # CRAN
library(Seurat, quietly = T) # CRAN
library(dplyr, quietly = T) # CRAN
library(viridis, quietly = T) # CRAN
library(sctransform, quietly = T) # CRAN
library(RANN, quietly = T) # CRAN
library(ggrastr, quietly = T) # CRAN
library(cowplot)
library(paletteer)
library(scry, quietly = T) # bioconductor
library(SingleCellExperiment, quietly = T) # bioconductor
```

# Load Data

```{r}
iss_expr <- readRDS("janesick_2023/raw_clean/iss_expr_clean.RDS")
iss_meta <- readRDS("janesick_2023/raw_clean/iss_meta_clean.RDS")
```

### Goal:  
classify cells as surface / core

```{r, fig.width=7.87, fig.height = 6.5, dpi=300, dev='tiff', out.width='100%'}
# Parameters
R <- 50  # Radius for neighborhood definition
center_x <- 3250
center_y <- 2075
threshold <- 0.90  # Threshold for Core vs Surface classification

# Create circle coordinates
circle <- data.frame(
  x = center_x + R * cos(seq(0, 2*pi, length.out = 500)),
  y = center_y + R * sin(seq(0, 2*pi, length.out = 500))
)

# p1 - Main plot
p1 <- ggplot(iss_meta, aes(x = x_centroid, y = y_centroid)) +
  geom_point(color = "grey", size = 0.01, alpha = 0.8, shape = '.') +
  geom_path(data = circle, aes(x = x, y = y), color = "black", linewidth = 0.3) +
  scale_x_reverse() +
  coord_fixed() +
  guides(color = guide_legend(override.aes = list(shape = 16, size = 3))) +
  theme_minimal() +
  theme(
    legend.position = "bottom", 
    legend.box = "horizontal", 
    legend.margin = margin(0, 0, 0, 0), 
    plot.margin = margin(0, 0, 0, 0, "pt")
  )


# p2 - zoomed in plot
zoom_margin <- 2.5 * R
x_min_zoom <- center_x - zoom_margin
x_max_zoom <- center_x + zoom_margin
y_min_zoom <- center_y - zoom_margin
y_max_zoom <- center_y + zoom_margin

p2 <- ggplot(iss_meta, aes(x = x_centroid, y = y_centroid)) +
  geom_point(color = "grey", size = 2, alpha = 0.8, shape = 16) + # Increase point size for visibility
  geom_path(data = circle, aes(x = x, y = y), color = "black", linewidth = 0.5) +
  scale_x_reverse() + # Keep the same reversed x-axis direction
  coord_fixed(xlim = c(x_min_zoom, x_max_zoom), ylim = c(y_min_zoom, y_max_zoom)) + # Zoom in and keep it square
  labs(x = NULL, y = NULL) + # Remove axis labels for a cleaner inset
  theme_bw() + # Use a simple theme
  theme(
    plot.background = element_rect(fill = "white", color = "black", linewidth = 0.5), # White background with border
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text = element_text(size = 6),
    plot.title = element_text(size = 8, hjust = 0.5),
    plot.margin = margin(2, 2, 2, 2, "pt")
  ) +
  ggtitle("Zoomed View")

# final_plot - Superimpose p2 on p1 using cowplot
final_plot <- ggdraw(p1) +
  draw_plot(
    p2,
    x = 0.10, # Start 65% from the left (Bottom Right Position)
    y = 0.20, # Start 10% from the bottom (Bottom Right Position)
    width = 0.3, # Square width
    height = 0.3  # Square height
  )

final_plot
```
  
# RADIUS METHOD
```{r}
iss_meta <- data.table(
  cell_id = iss_meta$cell_id,
  x_centroid = iss_meta$x_centroid,
  y_centroid = iss_meta$y_centroid,
  Annotation = iss_meta$Annotation
)
coords <- iss_meta[, .(x_centroid, y_centroid)]

# Perform radius search
nn_result <- nn2(data = coords, query = coords, searchtype = "radius", radius = R)

adj_list <- vector("list", nrow(iss_meta))
names(adj_list) <- iss_meta$cell_id

for (i in 1:nrow(iss_meta)) {
  neighbor_idx <- nn_result$nn.idx[i, ]
  neighbor_idx <- neighbor_idx[neighbor_idx != 0 & neighbor_idx != i]  # remove 0s and self
  adj_list[[i]] <- iss_meta$cell_id[neighbor_idx]
}

target_cells <- iss_meta[Annotation %in% c("Invasive_Tumor", "Prolif_Invasive_Tumor"), cell_id]

core_surface <- data.table(cell_id = target_cells, Classification = NA_character_)

for (i in seq_along(target_cells)) {
  cell <- target_cells[i]
  neighbors <- adj_list[[as.character(cell)]]
  
  if (length(neighbors) == 0) {
    core_surface[i, Classification := "Surface"]
    next
  }
  
  num_target_neighbors <- sum(neighbors %in% target_cells)
  fraction <- num_target_neighbors / length(neighbors)
  
  if (fraction > threshold) {
    core_surface[i, Classification := "Core"]
  } else {
    core_surface[i, Classification := "Surface"]
  }
}
```

```{r}
iss_meta <- merge(iss_meta, core_surface, by = "cell_id", all.x = TRUE)
iss_meta[, surface_class_radius := ifelse(is.na(Classification), "Other", Classification)]
```

```{r}
table(iss_meta$surface_class_radius)
```


```{r}
# Make Seurat object with ISS data
iss_obj <- CreateSeuratObject(counts = iss_expr, meta.data = iss_meta)

# filter to invasive cells only
iss_obj_invasive <- subset(iss_obj, subset = Annotation %in% 'Invasive_Tumor')
saveRDS(iss_obj_invasive, file = "janesick_2023/processed/iss_obj_invasive.RDS")
```

# Plot
```{r, fig.width=7.87, fig.height = 6.5, dpi=300, dev='tiff', out.width='100%'}

# Find surface cells
subset_cells <- iss_meta[
  iss_meta$x_centroid >= 3240 &
  iss_meta$x_centroid <= 3320 &
  iss_meta$y_centroid >= 2000 &
  iss_meta$y_centroid <= 2100 &
  iss_meta$surface_class_radius == "Surface",
  "cell_id"
]
surface_cell <- iss_meta[iss_meta$cell_id == 91969,]
center_x <- surface_cell$x_centroid
center_y <- surface_cell$y_centroid
#define circle
circle <- data.frame(
  x = center_x + R * cos(seq(0, 2*pi, length.out = 500)),
  y = center_y + R * sin(seq(0, 2*pi, length.out = 500))
)


# p1 - main plot

p1 <- ggplot(iss_meta, aes(x = x_centroid, y = y_centroid)) +
  geom_point(aes(color = surface_class_radius), size = 0.01, alpha = 0.8, shape = '.') +
  geom_path(data = circle, aes(x = x, y = y), color = "black", linewidth = 0.3) +
  scale_color_manual(values = c("Surface" = "#C90065", "Core" = "#fac0da", "Other" = "grey75"), na.value = "grey75") +
  scale_x_reverse() +
  coord_fixed() +
  guides(color = guide_legend(override.aes = list(shape = 16, size = 3))) +
  theme_minimal() +
  theme(
    legend.position = "bottom", 
    legend.box = "horizontal", 
    legend.margin = margin(0, 0, 0, 0), 
    plot.margin = margin(0, 0, 0, 0, "pt")
  )

# p2 - superimpose zoomed view
zoom_margin <- 2.5 * R
x_min_zoom <- center_x - zoom_margin
x_max_zoom <- center_x + zoom_margin
y_min_zoom <- center_y - zoom_margin
y_max_zoom <- center_y + zoom_margin

p2 <- ggplot(iss_meta, aes(x = x_centroid, y = y_centroid)) +
  geom_point(aes(color = surface_class_radius), size = 2, alpha = 0.8, shape = 16) + 
  geom_path(data = circle, aes(x = x, y = y), color = "black", linewidth = 0.5) +
  scale_color_manual(values = c("Surface" = "#C90065", "Core" = "#fac0da", "Other" = "grey75"), na.value = "grey75") +
  scale_x_reverse() +
  # Force the zoom window
  coord_fixed(xlim = c(x_min_zoom, x_max_zoom), ylim = c(y_min_zoom, y_max_zoom)) + 
  labs(x = NULL, y = NULL) +
  theme_bw() +
  theme(
    legend.position = "none", # Hide legend in the inset
    plot.background = element_rect(fill = "white", color = "black", linewidth = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text = element_text(size = 6),
    plot.title = element_text(size = 8, hjust = 0.5),
    plot.margin = margin(0, 0, 0, 0, "pt")
  ) +
  ggtitle("Zoomed View")

# final plot
plot_ratio <- 7.87 / 6.5
inset_width <- 0.3
inset_height <- inset_width * plot_ratio

final_plot <- ggdraw(p1) +
  draw_plot(
    p2,
    x = 0.12, # 65% from left (Right side)
    y = 0.20, # 10% from bottom (Bottom side)
    width = inset_width, 
    height = inset_height
  )

final_plot
```


# KNN METHOD
```{r}
# Get invasive cells
invasive_cells <- iss_meta[iss_meta$Annotation == "Invasive_Tumor", ]
iss_meta$perc_tumours <- NA_real_ # NA_real_ is an NA value in place of a floating point number

start_time <- Sys.time()

# Extract coordinates matrix for nearest-neighbor search
coords_all <- as.matrix(iss_meta[, c("x_centroid", "y_centroid")])
coords_invasive <- as.matrix(invasive_cells[, c("x_centroid", "y_centroid")])

# Find 31 nearest neighbors for each invasive cell (includes the cell itself)
# nn2 is extremely fast (uses KD-trees in C++)
nn <- RANN::nn2(data = coords_all, query = coords_invasive, k = 21)

# Indices of nearest neighbors (each row = one invasive cell)
neighbor_indices <- nn$nn.idx[, -1, drop = FALSE]  # remove self, keep matrix

# Create a logical vector: which cells are tumourous?
tumourous_flags <- iss_meta$Annotation %in% c("Invasive_Tumor", "Prolif_Invasive_Tumor")

# Calculate percentage of tumourous neighbors for each invasive cell safely
perc_tumours <- apply(neighbor_indices, 1, function(idx) {
  mean(tumourous_flags[idx])
})

# Assign values back to main data frame
iss_meta$perc_tumours[match(invasive_cells$cell_id, iss_meta$cell_id)] <- perc_tumours

save(iss_meta, file = 'cells_RANN.RData')

end_time <- Sys.time()

cat("Classification took:", round(end_time - start_time, 2), "seconds.")
```

```{r}
# Set surface / core labels based on the percentage of neighbours that are tumours (perc_tumours)
threshold <- 0.90
iss_meta$surface_class_nn <- ifelse(
  is.na(iss_meta$perc_tumours), NA_character_,
  ifelse(iss_meta$perc_tumours < threshold, "Surface", "Core")
)
table(iss_meta$surface_class_nn)
```

```{r}
# Make Seurat object with ISS data
iss_obj <- CreateSeuratObject(counts = iss_expr, meta.data = iss_meta)

# filter to invasive cells only
iss_obj_invasive <- subset(iss_obj, subset = Annotation %in% 'Invasive_Tumor')
saveRDS(iss_obj_invasive, file = "janesick_2023/processed/iss_obj_invasive.RDS")
```

```{r}
ggplot(iss_meta, aes(x = x_centroid, y = y_centroid)) +
  geom_point(aes(color = surface_class_nn), size = 0.01, alpha = 0.8, shape = '.') +
  scale_color_manual(values = c("Surface" = "#C90065", "Core" = "#fac0da", "Other" = "grey75"), na.value = "grey75") +
  scale_x_reverse() +
  coord_fixed() +
  guides(color = guide_legend(override.aes = list(shape = 16, size = 3))) +
  theme_minimal() +
  theme(
    legend.position = "bottom", 
    legend.box = "horizontal", 
    legend.margin = margin(0, 0, 0, 0), 
    plot.margin = margin(0, 0, 0, 0, "pt")
    )
```


# GRADIENT METHOD
```{r}
# Calculate tumour_depth: distance from core cells to nearest surface cell
# Surface cells get depth = 0

# Initialize tumour_depth column
iss_meta$tumour_depth <- NA_real_

# Set surface cells to depth 0
iss_meta$tumour_depth[iss_meta$surface_class_nn == "Surface"] <- 0

# Get core cells
core_cells <- iss_meta[iss_meta$surface_class_nn == "Core", ]

if (nrow(core_cells) > 0) {
  # Get surface cell coordinates
  surface_cells <- iss_meta[iss_meta$surface_class_nn == "Surface", ]
  
  if (nrow(surface_cells) > 0) {
    # Extract coordinate matrices
    coords_surface <- as.matrix(surface_cells[, c("x_centroid", "y_centroid")])
    coords_core <- as.matrix(core_cells[, c("x_centroid", "y_centroid")])
    
    # Find nearest surface cell for each core cell
    nn <- RANN::nn2(data = coords_surface, query = coords_core, k = 1)
    
    # nn$nn.dists contains the distances to nearest surface cell
    nearest_surface_dist <- nn$nn.dists[, 1]
    
    # Assign distances back to main dataframe
    iss_meta$tumour_depth[match(core_cells$cell_id, iss_meta$cell_id)] <- nearest_surface_dist
  }
}

# Check results
summary(iss_meta$tumour_depth[iss_meta$surface_class_nn == "Core"])
summary(iss_meta$tumour_depth[iss_meta$surface_class_nn == "Surface"])
```

```{r}
ggplot(iss_meta, aes(x = x_centroid, y = y_centroid)) +
  geom_point(aes(color = tumour_depth), size = 0.1) +
  scale_color_gradientn(
    colors = paletteer_c("grDevices::Blue-Red 3", 30),
    na.value = "grey75",
    guide = guide_colorbar(
      barwidth = 1,   # length of the color bar
      barheight = 10,   # thickness
      ticks = FALSE,   # remove ticks if desired
      label.position = "right" # put labels on right
    ) 
  ) +
  scale_x_reverse() +
  coord_fixed() +
  theme_minimal() +
  theme(
    legend.position = "right", 
    legend.box = "vertical", 
    legend.margin = margin(0, 0, 0, 0), 
    plot.margin = margin(0, 0, 0, 0, "pt")
    )
```

# GENE EXPRESSION METHOD
```{r}
# Cluster
iss_obj_invasive <- NormalizeData(iss_obj_invasive)

iss_obj_invasive <- FindVariableFeatures(iss_obj_invasive)

iss_obj_invasive <- ScaleData(iss_obj_invasive)

iss_obj_invasive <- RunPCA(iss_obj_invasive)

ElbowPlot(iss_obj_invasive, ndims = 50, reduction = 'pca')

iss_obj_invasive_nn <- FindNeighbors(iss_obj_invasive, dims = 1:10)
```

```{r}
iss_obj_invasive_clustered <- FindClusters(iss_obj_invasive_nn, resolution = 0.3, algorithm = 4)

iss_obj_invasive_clustered <- RunUMAP(iss_obj_invasive_clustered, dims = 1:10)

DimPlot(iss_obj_invasive_clustered, group.by = "seurat_clusters", label = F) + scale_color_viridis_d(option = "turbo", na.value = "grey75") + ggtitle("Leiden Clustering of Invasive Tumour Cells")
```

```{r}
# Ensure 'cell_id' in 'cells' is character
iss_meta$cell_id <- as.character(iss_meta$cell_id)

# Extract Seurat cluster assignments for invasive tumor cells
clusters <- Idents(iss_obj_invasive_clustered)  # vector of cluster labels
cluster_df <- data.frame(
  cell_id = names(clusters),
  cluster = as.character(clusters),
  stringsAsFactors = FALSE
)

# Merge cluster info into 'cells'
iss_meta <- merge(iss_meta, cluster_df, by = "cell_id", all.x = TRUE)
saveRDS(iss_meta, "janesick_2023/processed/iss_meta.RDS")
```

```{r}
ggplot(iss_meta, aes(x = x_centroid, y = y_centroid)) +
  geom_point(aes(color = cluster), size = 0.1) +
  scale_color_viridis_d(option = "turbo", na.value = "grey75") +
  scale_x_reverse() +
  coord_fixed() +
  guides(color = guide_legend(override.aes = list(shape = 16, size = 3))) +
  theme_minimal() +
  theme(
    legend.position = "bottom", 
    legend.box = "horizontal", 
    legend.margin = margin(0, 0, 0, 0), 
    plot.margin = margin(0, 0, 0, 0, "pt")
    )
```

```{r}
# cluster's 4, 5 are NA
# cluster 3 is surface
# clusters 1, 2 are core
iss_meta <- iss_meta %>%
  mutate(surface_class_clusters = case_when(cluster %in% c(1,2) ~ "Core", 
                                            cluster %in% c(3) ~ "Surface", 
                                            cluster %in% c(4,5) ~ NA_character_,
                                            TRUE ~ NA_character_
  ))

table(iss_meta$surface_class_clusters)
```

```{r}
# Make Seurat object with ISS data
iss_obj <- CreateSeuratObject(counts = iss_expr, meta.data = iss_meta)

# filter to invasive cells only
iss_obj_invasive <- subset(iss_obj, subset = Annotation %in% 'Invasive_Tumor')
saveRDS(iss_obj_invasive, file = "janesick_2023/processed/iss_obj_invasive.RDS")
```

