---
output:
  pdf_document:
    latex_engine: xelatex
geometry: margin=0.2in
---

```{r setup, include=FALSE, message = FALSE, warning = FALSE}
# Load config.R
source("/home/glennrdx/Documents/lab_projects/microenvironments/02_analysis/config.R") 

# Set root directory using the variable from config
knitr::opts_knit$set(root.dir = data_dir)

# Load libraries
library(tidyverse)
library(data.table)
library(randomForest)
library(caret)
library(ggplot2)
library(viridis)
library(ggrastr)

set.seed(42)  # For reproducibility
```

# Load Data

```{r load_data}
# Load gene expression matrix
ISS_gene_expression <- fread("ISS_gene_expression.txt", header = TRUE)
rownames(ISS_gene_expression) <- ISS_gene_expression[[1]]
ISS_gene_expression[[1]] <- NULL
colnames(ISS_gene_expression) <- as.character(colnames(ISS_gene_expression))

# Load cells with tumor depth annotations
load('cells_RANN.RData')

# Check data dimensions
cat("Gene expression matrix:", nrow(ISS_gene_expression), "genes x", 
    ncol(ISS_gene_expression), "cells\n")
cat("Cells dataframe:", nrow(cells), "cells\n")
```

# Prepare Training Data

```{r prepare_data}
# Filter to only invasive tumor cells with tumor_depth values
invasive_tumor_cells <- cells %>%
  filter(surface_class %in% c("Surface", "Core")) %>%
  filter(!is.na(tumour_depth))

cat("Number of invasive tumor cells for training:", nrow(invasive_tumor_cells), "\n")
cat("Tumor depth range:", min(invasive_tumor_cells$tumour_depth), 
    "to", max(invasive_tumor_cells$tumour_depth), "\n")

# Extract gene expression for these cells
# Transpose so cells are rows and genes are columns
gene_expr_subset <- t(ISS_gene_expression[, invasive_tumor_cells$cell_id, with = FALSE])
gene_expr_df <- as.data.frame(gene_expr_subset)

# Add tumor depth as target variable
gene_expr_df$tumour_depth <- invasive_tumor_cells$tumour_depth

# Add spatial coordinates for spatial cross-validation
gene_expr_df$x_centroid <- invasive_tumor_cells$x_centroid
gene_expr_df$y_centroid <- invasive_tumor_cells$y_centroid
gene_expr_df$cell_id <- invasive_tumor_cells$cell_id

cat("Training data prepared:", nrow(gene_expr_df), "cells x", 
    ncol(gene_expr_df) - 4, "genes\n")
```

# Spatial Cross-Validation Split

```{r spatial_split}
# Create spatial folds by dividing the tissue into grid regions
# This prevents data leakage from spatially adjacent cells

# Define number of spatial bins
n_x_bins <- 5
n_y_bins <- 5

# Create spatial bins
gene_expr_df$x_bin <- cut(gene_expr_df$x_centroid, 
                           breaks = n_x_bins, 
                           labels = FALSE)
gene_expr_df$y_bin <- cut(gene_expr_df$y_centroid, 
                           breaks = n_y_bins, 
                           labels = FALSE)
gene_expr_df$spatial_fold <- paste0(gene_expr_df$x_bin, "_", gene_expr_df$y_bin)

# Visualize spatial folds
ggplot(gene_expr_df, aes(x = x_centroid, y = y_centroid, color = spatial_fold)) +
  geom_point(size = 0.3, alpha = 0.5) +
  scale_x_reverse() +
  coord_fixed() +
  theme_minimal() +
  labs(title = "Spatial Folds for Cross-Validation") +
  theme(legend.position = "none")

# Create train/test split (80/20) using spatial stratification
unique_folds <- unique(gene_expr_df$spatial_fold)
n_folds <- length(unique_folds)
n_train_folds <- ceiling(n_folds * 0.8)

set.seed(42)
train_folds <- sample(unique_folds, n_train_folds)

train_data <- gene_expr_df %>% filter(spatial_fold %in% train_folds)
test_data <- gene_expr_df %>% filter(!spatial_fold %in% train_folds)

cat("Training set:", nrow(train_data), "cells\n")
cat("Test set:", nrow(test_data), "cells\n")

# Remove spatial columns from modeling data
features <- setdiff(colnames(gene_expr_df), 
                    c("tumour_depth", "x_centroid", "y_centroid", 
                      "cell_id", "x_bin", "y_bin", "spatial_fold"))

X_train <- train_data[, features]
y_train <- train_data$tumour_depth

X_test <- test_data[, features]
y_test <- test_data$tumour_depth
```

# Train Random Forest Model

```{r train_model}
cat("Training Random Forest model...\n")
start_time <- Sys.time()

# Train Random Forest with optimized parameters
rf_model <- randomForest(
  x = X_train,
  y = y_train,
  ntree = 500,              # Number of trees
  mtry = floor(sqrt(ncol(X_train))),  # Number of variables at each split
  importance = TRUE,        # Calculate variable importance
  nodesize = 5,             # Minimum size of terminal nodes
  maxnodes = NULL,          # Maximum number of terminal nodes
  keep.forest = TRUE
)

end_time <- Sys.time()
cat("Training completed in", round(difftime(end_time, start_time, units = "mins"), 2), "minutes\n")

# Print model summary
print(rf_model)
```

# Model Evaluation

```{r evaluate_model}
# Make predictions on test set
test_predictions <- predict(rf_model, X_test)

# Calculate performance metrics
rmse <- sqrt(mean((y_test - test_predictions)^2))
mae <- mean(abs(y_test - test_predictions))
r_squared <- cor(y_test, test_predictions)^2
mape <- mean(abs((y_test - test_predictions) / (y_test + 1))) * 100

cat("\n=== Model Performance on Test Set ===\n")
cat("RMSE:", round(rmse, 3), "\n")
cat("MAE:", round(mae, 3), "\n")
cat("R²:", round(r_squared, 3), "\n")
cat("MAPE:", round(mape, 2), "%\n")

# Performance by depth bins
test_results <- data.frame(
  actual = y_test,
  predicted = test_predictions,
  depth_bin = cut(y_test, breaks = c(0, 20, 40, 60, 80, 140), 
                  labels = c("0-20", "20-40", "40-60", "60-80", "80+"))
)

# Calculate metrics by depth bin
performance_by_bin <- test_results %>%
  group_by(depth_bin) %>%
  summarise(
    n = n(),
    rmse = sqrt(mean((actual - predicted)^2)),
    mae = mean(abs(actual - predicted)),
    r_squared = cor(actual, predicted)^2
  )

print(performance_by_bin)
```

# Visualize Predictions

```{r plot_predictions, fig.width=12, fig.height=5}
# Predicted vs Actual plot
p1 <- ggplot(test_results, aes(x = actual, y = predicted)) +
  geom_point(alpha = 0.3, color = "#C90065") +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black") +
  geom_smooth(method = "lm", se = TRUE, color = "blue", linewidth = 0.8) +
  labs(
    title = "Predicted vs Actual Tumor Depth",
    x = "Actual Tumor Depth (pixels)",
    y = "Predicted Tumor Depth (pixels)"
  ) +
  annotate("text", x = max(y_test) * 0.1, y = max(y_test) * 0.9,
           label = paste0("R² = ", round(r_squared, 3), "\nRMSE = ", round(rmse, 2)),
           hjust = 0, size = 4) +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold"))

# Residuals plot
test_results$residuals <- test_results$actual - test_results$predicted

p2 <- ggplot(test_results, aes(x = predicted, y = residuals)) +
  geom_point(alpha = 0.3, color = "#C90065") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_smooth(method = "loess", se = TRUE, color = "blue", linewidth = 0.8) +
  labs(
    title = "Residual Plot",
    x = "Predicted Tumor Depth (pixels)",
    y = "Residuals (Actual - Predicted)"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold"))

gridExtra::grid.arrange(p1, p2, ncol = 2)
```

# Feature Importance

```{r feature_importance, fig.width=10, fig.height=8}
# Extract feature importance
importance_df <- data.frame(
  gene = rownames(importance(rf_model)),
  IncMSE = importance(rf_model)[, "%IncMSE"],
  IncNodePurity = importance(rf_model)[, "IncNodePurity"]
)

# Sort by %IncMSE and get top 30 genes
importance_df <- importance_df %>%
  arrange(desc(IncMSE)) %>%
  slice(1:30)

# Plot top 30 most important genes
ggplot(importance_df, aes(x = reorder(gene, IncMSE), y = IncMSE)) +
  geom_col(fill = "#C90065", alpha = 0.8) +
  coord_flip() +
  labs(
    title = "Top 30 Most Important Genes for Tumor Depth Prediction",
    x = "Gene",
    y = "% Increase in MSE (Importance)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold"),
    axis.text.y = element_text(size = 8)
  )

# Save top genes to CSV
write.csv(importance_df, "top_genes_importance.csv", row.names = FALSE)
cat("\nTop gene importance saved to: top_genes_importance.csv\n")
```

# Spatial Visualization of Predictions

```{r, fig.width=35, fig.height=35, out.width="100%"}
# Add predictions to test data
test_data$predicted_depth <- test_predictions
test_data$prediction_error <- abs(y_test - test_predictions)

# Plot actual vs predicted spatially
p_actual <- ggplot(test_data, aes(x = x_centroid, y = y_centroid)) +
  rasterise(geom_point(aes(color = tumour_depth), size = 0.5, alpha = 0.8), dpi = 300) +
  scale_color_viridis(option = "plasma", name = "Actual Depth") +
  scale_x_reverse() +
  coord_fixed() +
  labs(title = "Actual Tumor Depth (Test Set)") +
  theme_minimal() +
  theme(legend.position = "right")

p_predicted <- ggplot(test_data, aes(x = x_centroid, y = y_centroid)) +
  rasterise(geom_point(aes(color = predicted_depth), size = 0.5, alpha = 0.8), dpi = 300) +
  scale_color_viridis(option = "plasma", name = "Predicted Depth") +
  scale_x_reverse() +
  coord_fixed() +
  labs(title = "Predicted Tumor Depth (Test Set)") +
  theme_minimal() +
  theme(legend.position = "right")

p_error <- ggplot(test_data, aes(x = x_centroid, y = y_centroid)) +
  rasterise(geom_point(aes(color = prediction_error), size = 0.5, alpha = 0.8), dpi = 300) +
  scale_color_viridis(option = "magma", name = "Absolute Error") +
  scale_x_reverse() +
  coord_fixed() +
  labs(title = "Prediction Error (Test Set)") +
  theme_minimal() +
  theme(legend.position = "right")

gridExtra::grid.arrange(p_actual, p_predicted, p_error, ncol = 1)
```

# Save Model and Results

```{r save_model}
# Save the trained model
saveRDS(rf_model, "rf_tumor_depth_model.rds")
cat("Model saved to: rf_tumor_depth_model.rds\n")

# Save test results
test_results_full <- test_data %>%
  select(cell_id, x_centroid, y_centroid, tumour_depth, 
         predicted_depth, prediction_error)
write.csv(test_results_full, "test_predictions.csv", row.names = FALSE)
cat("Test predictions saved to: test_predictions.csv\n")
---
output:
  pdf_document:
    latex_engine: xelatex
geometry: margin=0.2in
---
# Load Packages

```{r setup, include=FALSE, message = FALSE, warning = FALSE}
knitr::opts_knit$set(root.dir = "/home/glennrdx/Documents/lab_projects/microenvironments/01_data/")

# Load libraries
library(tidyverse, quietly = T) # CRAN
library(Matrix, quietly = T) # CRAN
library(ggplot2, quietly = T) # CRAN
library(data.table, quietly = T) # CRAN
library(Seurat, quietly = T) # CRAN
library(dplyr, quietly = T) # CRAN
library(viridis, quietly = T) # CRAN
library(sctransform, quietly = T) # CRAN
library(RANN, quietly = T) # CRAN
library(ggrastr, quietly = T) # CRAN
library(scry, quietly = T) # bioconductor
library(SingleCellExperiment, quietly = T) # bioconductor
```

# Load / clean data & create Seurat object

```{r}
# Load & clean ISS expression matrix
ISS_gene_expression <- fread("ISS_gene_expression.txt", header = TRUE) # load file
rownames(ISS_gene_expression) <- ISS_gene_expression[[1]] # set rownames to the gene names stored in column 1
ISS_gene_expression[[1]] <- NULL # now remove column 1
colnames(ISS_gene_expression) <- as.character(colnames(ISS_gene_expression)) # ensure colnames are strings
```

```{r}
# Load & clean ISS annotations
ISS_cell_types   <- fread("ISS_cell_types.txt", skip = 1, header = TRUE) # load file
ISS_cell_types <- data.frame(t(ISS_cell_types)) # transpose so cells are rows
colnames(ISS_cell_types) <- c('Annotation') # label row as 'annotations'
rownames(ISS_cell_types) <- as.character(rownames(ISS_cell_types)) # ensure colnames are string
```

```{r}
# Load ISS cell meta data (containing spatial coordinates)
cells <- fread("cells.csv")
cells$Annotation <- ISS_cell_types$Annotation
```

```{r}
# Create Seurat objects
# ISS_obj = CreateSeuratObject(counts = ISS_gene_expression, meta.data = ISS_cell_types)
```

# Part 2: Classifying invasive tumours as surface / core

### Goal:  
Determine the percentage of tumourous neighbours of 20 closest cells for each invasive tumour. 'cells' object contains a row for each cell and annotation columns for various features.
 - A new feature will be created called 'perc_tumours' representing this number.

### Method:  
#### Step 1:
For each invasive tumour in 'cells':
  - Calculate square region around the centroid  
  - For all cells in that region, calculate distance to initial invasive tumour cell  
  - Filter to top 30 closest neighbouring cells  
  - Calculate percentage of neighbours that are tumourous and save number in 'cells' dataframe  
  
#### Step 2:
Plot spatial data, where:
  - non invasive tumours are grey  
  - invasive tumours with less than 95% of tumourous neighbours are dark pink (surface)  
  - invasive tumours with more than 95% of tumourous neighbours are light pink (core)  
  
```{r}
# Get invasive cells
invasive_cells <- cells[cells$Annotation == "Invasive_Tumor", ]
cells$perc_tumours <- NA_real_ # NA_real_ is an NA value in place of a floating point number

start_time <- Sys.time()

# Extract coordinates matrix for nearest-neighbor search
coords_all <- as.matrix(cells[, c("x_centroid", "y_centroid")])
coords_invasive <- as.matrix(invasive_cells[, c("x_centroid", "y_centroid")])

# Find 31 nearest neighbors for each invasive cell (includes the cell itself)
# nn2 is extremely fast (uses KD-trees in C++)
nn <- RANN::nn2(data = coords_all, query = coords_invasive, k = 21)

# Indices of nearest neighbors (each row = one invasive cell)
neighbor_indices <- nn$nn.idx[, -1, drop = FALSE]  # remove self, keep matrix

# Create a logical vector: which cells are tumourous?
tumourous_flags <- cells$Annotation %in% c("Invasive_Tumor", "Prolif_Invasive_Tumor")

# Calculate percentage of tumourous neighbors for each invasive cell safely
perc_tumours <- apply(neighbor_indices, 1, function(idx) {
  mean(tumourous_flags[idx])
})

# Assign values back to main data frame
cells$perc_tumours[match(invasive_cells$cell_id, cells$cell_id)] <- perc_tumours

save(cells, file = 'cells_RANN.RData')

end_time <- Sys.time()

end_time - start_time

```

\newpage

# Plot

```{r, fig.width=35, fig.height=35, out.width="100%"}
threshold <- 0.90
cells$surface_class <- ifelse(
  is.na(cells$perc_tumours), "Other",
  ifelse(cells$perc_tumours < threshold, "Surface", "Core")
)

ggplot(cells, aes(x = x_centroid, y = y_centroid)) +
  rasterise(geom_point(aes(color = surface_class), size = 0.5, alpha = 0.8), dpi = 300) +
  scale_color_manual(
    values = c("Surface" = "#C90065", "Core" = "#fac0da", "Other" = "grey75"),
    na.value = "grey75"
  ) +
  scale_x_reverse() +
  coord_fixed() +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    legend.box = "horizontal",
    plot.margin = margin(t = 5, r = 5, b = 5, l = 5, unit = "pt"),
    axis.title.x = element_text(margin = margin(t = 2)),
    axis.title.y = element_text(margin = margin(r = 2)),
    axis.text = element_text(size = 20),
    legend.text = element_text(size = 20),
    legend.title = element_text(size = 20),
    panel.background = element_rect(fill = "snow", color = NA),
    plot.background = element_rect(fill = "snow", color = NA),
    panel.grid.major = element_line(color = "grey90", linewidth = 2),
    panel.grid.minor = element_line(color = "grey90", linewidth = 2),
    axis.ticks.length = unit(1, "pt"),
    axis.ticks = element_line(color = "grey90")
  ) +
  guides(color = guide_legend(override.aes = list(size = 4)))
```

# Calculate 'tumour_depth' value

```{r}
# Calculate tumour_depth: distance from core cells to nearest surface cell
# Surface cells get depth = 0

# Initialize tumour_depth column
cells$tumour_depth <- NA_real_

# Set surface cells to depth 0
cells$tumour_depth[cells$surface_class == "Surface"] <- 0

# Get core cells
core_cells <- cells[cells$surface_class == "Core", ]

if (nrow(core_cells) > 0) {
  # Get surface cell coordinates
  surface_cells <- cells[cells$surface_class == "Surface", ]
  
  if (nrow(surface_cells) > 0) {
    # Extract coordinate matrices
    coords_surface <- as.matrix(surface_cells[, c("x_centroid", "y_centroid")])
    coords_core <- as.matrix(core_cells[, c("x_centroid", "y_centroid")])
    
    # Find nearest surface cell for each core cell
    nn <- RANN::nn2(data = coords_surface, query = coords_core, k = 1)
    
    # nn$nn.dists contains the distances to nearest surface cell
    nearest_surface_dist <- nn$nn.dists[, 1]
    
    # Assign distances back to main dataframe
    cells$tumour_depth[match(core_cells$cell_id, cells$cell_id)] <- nearest_surface_dist
  }
}

# Check results
summary(cells$tumour_depth[cells$surface_class == "Core"])
summary(cells$tumour_depth[cells$surface_class == "Surface"])
```

# Plot of tumour depth

```{r, fig.width=35, fig.height=35, out.width="100%"}
ggplot(cells, aes(x = x_centroid, y = y_centroid)) +
  rasterise(geom_point(aes(color = tumour_depth), size = 0.5, alpha = 0.8), dpi = 300) +
  scale_color_gradientn(
    colors = paletteer_c("grDevices::Blue-Red 3", 30),
    na.value = "grey75"
  ) +
  scale_x_reverse() +
  coord_fixed() +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    legend.box = "horizontal",
    plot.margin = margin(t = 5, r = 5, b = 5, l = 5, unit = "pt"),
    axis.title.x = element_text(margin = margin(t = 2)),
    axis.title.y = element_text(margin = margin(r = 2)),
    axis.text = element_text(size = 20),
    legend.text = element_text(size = 20),
    legend.title = element_text(size = 20),
    panel.background = element_rect(fill = "snow", color = NA),
    plot.background = element_rect(fill = "snow", color = NA),
    panel.grid.major = element_line(color = "grey90", linewidth = 2),
    panel.grid.minor = element_line(color = "grey90", linewidth = 2),
    axis.ticks.length = unit(1, "pt"),
    axis.ticks = element_line(color = "grey90")
  ) +
  guides(color = guide_legend(override.aes = list(size = 4)))
```

```{r}
# Summary statistics
summary_stats <- data.frame(
  Metric = c("RMSE", "MAE", "R²", "MAPE"),
  Value = c(rmse, mae, r_squared, mape)
)
write.csv(summary_stats, "model_performance.csv", row.names = FALSE)
cat("Model performance saved to: model_performance.csv\n")
```

# Predict on New Data (Example)

```{r predict_new_data, eval=FALSE}
# To predict tumor depth for new invasive tumor cells:

# 1. Load the saved model
# rf_model <- readRDS("rf_tumor_depth_model.rds")

# 2. Prepare new data (must have same gene columns as training data)
# new_gene_expression <- t(ISS_gene_expression[, new_cell_ids, with = FALSE])
# new_gene_expression <- as.data.frame(new_gene_expression)

# 3. Make predictions
# new_predictions <- predict(rf_model, new_gene_expression)

# 4. Add predictions to your cells dataframe
# cells$predicted_tumour_depth[match(new_cell_ids, cells$cell_id)] <- new_predictions
```

# Calculate max cell depth in predicted & actual data.

```{r}
# Calculate the range for consistent color scaling
depth_range <- range(c(cells$tumour_depth, cells$predicted_tumour_depth), na.rm = TRUE)
depth_min <- depth_range[1]
depth_max <- depth_range[2]

cat("Depth range:", depth_min, "to", depth_max, "\n")
```

# Plot actual

```{r, fig.width=35, fig.height=35, out.width="100%"}
ggplot(cells, aes(x = x_centroid, y = y_centroid)) +
  rasterise(geom_point(aes(color = tumour_depth), size = 0.5, alpha = 0.8), dpi = 300) +
  scale_color_gradientn(
    colors = paletteer_c("grDevices::Blue-Red 3", 30),
    na.value = "grey75",
    limits = c(depth_min, depth_max)  # ADD THIS LINE
  ) +
  scale_x_reverse() +
  coord_fixed() +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    legend.box = "horizontal",
    plot.margin = ggplot2::margin(t = 5, r = 5, b = 5, l = 5, unit = "pt"),
    axis.title.x = element_text(margin = ggplot2::margin(t = 2)),
    axis.title.y = element_text(margin = ggplot2::margin(r = 2)),
    axis.text = element_text(size = 20),
    legend.text = element_text(size = 20),
    legend.title = element_text(size = 20),
    panel.background = element_rect(fill = "snow", color = NA),
    plot.background = element_rect(fill = "snow", color = NA),
    panel.grid.major = element_line(color = "grey90", linewidth = 2),
    panel.grid.minor = element_line(color = "grey90", linewidth = 2),
    axis.ticks.length = unit(1, "pt"),
    axis.ticks = element_line(color = "grey90")
  ) +
  guides(color = guide_legend(override.aes = list(size = 4)))
```


# Plot prediction

```{r, fig.width=35, fig.height=35, out.width="100%"}
# [Prediction code stays the same]
invasive_for_prediction <- cells %>%
  filter(surface_class %in% c("Surface", "Core")) %>%
  filter(!is.na(tumour_depth))

gene_expr_all_invasive <- t(ISS_gene_expression[, invasive_for_prediction$cell_id, with = FALSE])
gene_expr_all_invasive <- as.data.frame(gene_expr_all_invasive)

all_predictions <- predict(rf_model, gene_expr_all_invasive)

cells$predicted_tumour_depth <- NA_real_
cells$predicted_tumour_depth[match(invasive_for_prediction$cell_id, cells$cell_id)] <- all_predictions

# Plot with same color scale
ggplot(cells, aes(x = x_centroid, y = y_centroid)) +
  rasterise(geom_point(aes(color = predicted_tumour_depth), size = 0.5, alpha = 0.8), dpi = 300) +
  scale_color_gradientn(
    colors = paletteer_c("grDevices::Blue-Red 3", 30),
    na.value = "grey75",
    limits = c(depth_min, depth_max)  # ADD THIS LINE
  ) +
  scale_x_reverse() +
  coord_fixed() +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    legend.box = "horizontal",
    plot.margin = ggplot2::margin(t = 5, r = 5, b = 5, l = 5, unit = "pt"),
    axis.title.x = element_text(margin = ggplot2::margin(t = 2)),
    axis.title.y = element_text(margin = ggplot2::margin(r = 2)),
    axis.text = element_text(size = 20),
    legend.text = element_text(size = 20),
    legend.title = element_text(size = 20),
    panel.background = element_rect(fill = "snow", color = NA),
    plot.background = element_rect(fill = "snow", color = NA),
    panel.grid.major = element_line(color = "grey90", linewidth = 2),
    panel.grid.minor = element_line(color = "grey90", linewidth = 2),
    axis.ticks.length = unit(1, "pt"),
    axis.ticks = element_line(color = "grey90")
  ) +
  guides(color = guide_legend(override.aes = list(size = 4)))
```

